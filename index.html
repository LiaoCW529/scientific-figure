<!DOCTYPE html>
<html lang="ja" data-theme="light">
<head>
    <meta charset="UTF-8">
    <title>SVG Plotter v10 - Multi-Group Support</title>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        :root {
            --bg: #F3EFE6;
            --panel: #E7D7B8;
            --card: #F6F0E3;
            --border: #CBB489;
            --text: #2B2A27;
            --muted: #5D574C;
            --accent: #7B5A2B;
            --accent-2: #B07D2B;
            --danger: #B84A3A;
            --focus: #2F6FED;
            --input-bg: #F6F0E3;
            --input-text: #2B2A27;
            --input-border: #CBB489;
            --button-bg: var(--accent);
            --button-text: #ffffff;
            --button-hover: var(--accent-2);
            --button-active: #6a4b22;
            --button-disabled: #d9c7a4;
            --preview-bg: #EFE6D2;
            --preview-border: #CBB489;
            --svg-bg: #F6F0E3;
            --svg-ink: #2B2A27;
            --svg-muted: #5D574C;
            --explorer-bg: #E7D7B8;
            --explorer-text: #2B2A27;
            --explorer-muted: #5D574C;
            --explorer-border: #CBB489;
            --explorer-handle: #D7C6A6;
            --explorer-input-bg: #F6F0E3;
            --explorer-input-text: #2B2A27;
            --explorer-card: #F6F0E3;
            --explorer-hover: #E5D1A9;
            --explorer-selected: #D9BF8C;
        }
        html[data-theme="dark"] {
            --bg: #101214;
            --panel: #161A1D;
            --card: #1C2226;
            --border: #2A3238;
            --text: #E7E7E7;
            --muted: #A8B0B7;
            --accent: #D2A24C;
            --accent-2: #F0C66B;
            --danger: #FF6B5B;
            --focus: #7AA2F7;
            --input-bg: #1C2226;
            --input-text: #E7E7E7;
            --input-border: #2A3238;
            --button-bg: var(--accent);
            --button-text: #101214;
            --button-hover: var(--accent-2);
            --button-active: #b88935;
            --button-disabled: #2A3238;
            --preview-bg: #14181c;
            --preview-border: #2A3238;
            --svg-bg: #1C2226;
            --svg-ink: #E7E7E7;
            --svg-muted: #A8B0B7;
            --explorer-bg: #1f2d3d;
            --explorer-text: #f8f9fa;
            --explorer-muted: #cdd6e3;
            --explorer-border: #40556f;
            --explorer-handle: #2f4054;
            --explorer-input-bg: #233446;
            --explorer-input-text: #f8f9fa;
            --explorer-card: #1f2d3d;
            --explorer-hover: #2a3c52;
            --explorer-selected: #36506c;
        }
        body { font-family: -apple-system, sans-serif; margin: 20px; background: var(--bg); color: var(--text); }
        .container {
            display: flex;
            gap: 0;
            max-width: 100vw;
            height: 98vh;
            margin: 0 auto;
            align-items: flex-start;
        }
        .panel { background: var(--panel); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); }
        .input-area {
            flex: 0 0 250px;
            min-width: 0;
            max-width: 800px;
            position: sticky;
            top: 10px;
            max-height: 95vh;
            overflow-y: auto;
        }

        .preview-wrapper {
            display: grid;
            grid-template-columns: 50px 1fr;
            grid-template-rows: 1fr auto auto auto auto auto;
            gap: 10px;
            background: var(--preview-bg);
            padding: 30px;
            border: 2px dashed var(--preview-border);
            border-radius: 12px;
            align-items: center;
            justify-items: center;
            position: relative;
        }
        .slider-v { grid-column: 1; grid-row: 1; width: 12px; height: 400px; writing-mode: vertical-lr; direction: rtl; }
        .slider-h { grid-column: 2; grid-row: 2; width: 100%; height: 12px; }
        #svg-wrapper { grid-column: 2; grid-row: 1; background: var(--svg-bg); box-shadow: 0 8px 25px rgba(0,0,0,0.1); position: relative; justify-self: start; }
        html[data-theme="dark"] #svg-container svg { filter: brightness(0.92); }
        .resize-handle {
            width: 10px;
            height: 10px;
            background: #ff69b4;
            border: 1px solid #d84c8f;
            border-radius: 50%;
            position: absolute;
            z-index: 5;
        }
        .handle-pos {
            position: absolute;
            font-size: 0.7rem;
            color: var(--muted);
            background: var(--card);
            padding: 2px 4px;
            border-radius: 4px;
        }
        .resize-tl { top: -6px; left: -6px; cursor: nwse-resize; }
        .resize-tr { top: -6px; right: -6px; cursor: nesw-resize; }
        .resize-bl { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .resize-br { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .ymax-pos {
            font-size: 0.7rem;
            color: var(--muted);
        }
        .preview-row { display: flex; gap: 12px; align-items: flex-start; }
        .preview-wrapper { flex: 1; }
        .side-panels { display: flex; flex-direction: column; gap: 12px; width: 220px; }
        .legend-panel { width: 100%; align-self: flex-start; }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            height: 100vh;
            overflow-y: auto;
        }
        .stats-panel { background: var(--panel); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); }
        .longitudinal-area { display: none; flex-direction: column; gap: 16px; }
        .longitudinal-plot-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .longitudinal-plot-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            font-size: 0.9rem;
            color: var(--muted);
            margin-bottom: 10px;
        }
        .longitudinal-actions { display: flex; gap: 6px; }
        .longitudinal-btn {
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.7rem;
            cursor: pointer;
        }
        .longitudinal-btn:hover {
            border-color: var(--button-hover);
            background: var(--button-hover);
            color: var(--button-text);
        }
        .longitudinal-svg-wrapper {
            position: relative;
            display: inline-block;
        }
        .longitudinal-handle {
            width: 10px;
            height: 10px;
            background: #ff69b4;
            border: 1px solid #d84c8f;
            border-radius: 50%;
            position: absolute;
            z-index: 5;
        }
        .longitudinal-handle.tl { top: -6px; left: -6px; cursor: nwse-resize; }
        .longitudinal-handle.tr { top: -6px; right: -6px; cursor: nesw-resize; }
        .longitudinal-handle.bl { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .longitudinal-handle.br { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .longitudinal-size-row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        .longitudinal-size-row input[type="number"] {
            width: 70px;
        }
        .longitudinal-color-list {
            display: grid;
            gap: 6px;
            max-height: 160px;
            overflow: auto;
        }
        .code-board { background: var(--card) !important; color: var(--text) !important; padding: 15px; border-radius: 8px; font-family: "SF Mono", monospace; font-size: 11px; overflow-x: auto; white-space: pre; border: 1px solid var(--border); }
        .visual-controls { display: grid; grid-template-columns: repeat(3, minmax(220px, 1fr)); gap: 10px; }
        .control-card { background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 10px; display: flex; flex-direction: column; gap: 8px; }
        .control-card h4 { margin: 0; font-size: 0.85rem; color: var(--text); }
        .control-item { display: flex; flex-direction: column; gap: 4px; font-size: 0.75rem; min-width: 0; }
        .legend-panel { padding: 10px; }
        .control-item input[type="number"] { width: 70px; }
        .control-item input[type="range"] { width: 100%; }
        .legend-row { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
        .legend-row label { font-weight: normal; font-size: 0.75rem; color: var(--muted); }
        .legend-row input[type="number"] { width: 70px; }
        .option-list { display: grid; gap: 6px; font-size: 0.75rem; }
        .compact-row { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
        .ymax-card { grid-column: 2; grid-row: 1; justify-self: start; align-self: start; }
        .ymax-input { width: 34px; height: 30px; text-align: center; padding: 0; }
        .ymax-card { grid-column: 2; grid-row: 1; justify-self: start; align-self: start; }
        .ymax-input { width: 44px; height: 44px; text-align: center; padding: 0; }
        .card-grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .legend-move {
            display: grid;
            grid-template-columns: repeat(3, 22px);
            grid-auto-rows: 22px;
            gap: 4px;
            justify-items: center;
            align-items: center;
            margin-top: -6px;
            margin-bottom: 6px;
        }
        .legend-btn {
            width: 22px;
            height: 22px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            line-height: 1;
        }
        .auto-btn {
            width: 36px;
            height: 22px;
            padding: 0;
            margin: 0;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            border-radius: 4px;
            cursor: pointer;
        }
        .legend-input { width: 50%; }
        .legend-stack { gap: 6px; }
        .error-toggle { display: flex; gap: 6px; }
        .btn-mini {
            padding: 4px 8px;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            border-radius: 4px;
            cursor: pointer;
            width: 36px;
            height: 22px;
        }
        .btn-mini.active { background: var(--accent); color: var(--button-text); border-color: var(--accent); }
        .btn-mini:hover { background: var(--button-hover); border-color: var(--button-hover); color: var(--button-text); }
        .legend-btn:hover, .auto-btn:hover { background: var(--button-hover); border-color: var(--button-hover); color: var(--button-text); }
        .ymax-card { grid-column: 2; grid-row: 1; justify-self: start; align-self: start; }
        .ymax-input { width: 44px; height: 44px; text-align: center; padding: 0; }
        .card-grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .panel-tight { padding: 14px; }
        .panel-tight h3 { margin-bottom: 10px; }
        .ymax-inline {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .ymax-inline .control-item {
            gap: 2px;
        }
        .panel-disabled { opacity: 0.5; pointer-events: none; }

        .resizer {
            width: 8px;
            cursor: col-resize;
            background: var(--border);
            transition: background 0.2s;
            z-index: 10;
            height: 100%;
            align-self: stretch;
        }
        .resizer:hover { background: var(--accent); }

        /* グループカード関連 */
        .group-card { border: 1px solid var(--border); padding: 12px; border-radius: 8px; margin-bottom: 15px; position: relative; background: var(--card); }
        .group-header { display: flex; gap: 8px; margin-bottom: 8px; align-items: center; padding-right: 30px; }
        .btn-remove { position: absolute; top: 8px; right: 8px; background: var(--danger); color: white; border: none; border-radius: 4px; width: 24px; height: 24px; cursor: pointer; font-size: 12px; }
        textarea { width: 100%; height: 70px; font-family: "SF Mono", monospace; font-size: 11px; padding: 8px; border: 1px solid var(--input-border); border-radius: 4px; box-sizing: border-box; background: var(--input-bg); color: var(--input-text); }
        .paste-preview { margin-top: 6px; max-height: 140px; overflow: auto; border: 1px solid var(--border); border-radius: 4px; background: var(--card); }
        .paste-preview table { width: 100%; border-collapse: collapse; font-size: 0.7rem; }
        .paste-preview th, .paste-preview td { border: 1px solid var(--border); padding: 2px 4px; text-align: center; color: var(--text); }

        .master-label-card { background: var(--card) !important; border: 1px solid var(--border) !important; padding: 12px; border-radius: 8px; margin-bottom: 15px; color: var(--text); }
        .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; font-size: 0.85rem; }
        label { font-weight: bold; color: var(--muted); display: block; margin-bottom: 3px; }
        input[type="number"], input[type="range"], select, .text-input { width: 100%; padding: 6px; box-sizing: border-box; border: 1px solid var(--input-border); border-radius: 4px; background: var(--input-bg); color: var(--input-text); }
        input::placeholder, .text-input::placeholder { color: var(--muted); }
        input:focus, select:focus, .text-input:focus, button:focus-visible {
            outline: 2px solid var(--focus);
            outline-offset: 2px;
        }

        button { width: 100%; padding: 12px; margin-top: 10px; cursor: pointer; border: 1px solid var(--button-bg); border-radius: 6px; font-weight: bold; background: var(--button-bg); color: var(--button-text); }
        button:hover { background: var(--button-hover); border-color: var(--button-hover); }
        button:active { background: var(--button-active); border-color: var(--button-active); }
        button:disabled { background: var(--button-disabled); border-color: var(--button-disabled); color: var(--muted); cursor: not-allowed; }
        .btn-add { background: var(--button-bg); color: var(--button-text); margin-bottom: 20px; }
        .btn-gen { background: var(--button-bg); color: var(--button-text); }
        .btn-dl { background: var(--button-bg); color: var(--button-text); }
        .btn-small { width: 30%; margin-top: 0; padding: 5px 10px; font-size: 0.85rem; }
        .config-profile {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.85rem;
        }
        .config-profile .config-title { font-weight: bold; color: var(--muted); }
        .config-profile .config-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }
        .config-profile .btn-profile {
            width: auto;
            padding: 6px 10px;
            margin-top: 0;
            font-size: 0.8rem;
            border-radius: 4px;
            background: var(--button-bg);
            color: var(--button-text);
        }
        .panel-compact { padding: 10px; }
        .toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: #ffffff;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 0.85rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 999;
        }
        .toast.show { opacity: 1; }

        #explorer-panel {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 100vw;
            background: var(--explorer-bg);
            color: var(--explorer-text);
            transform: translateX(calc(-100% + 16px));
            transition: transform 0.25s ease;
            z-index: 2000;
            display: flex;
        }
        #explorer-panel.pinned {
            transform: translateX(0);
        }
        #explorer-handle {
            width: 16px;
            background: var(--explorer-handle);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            user-select: none;
        }
        #explorer-content {
            flex: 1;
            padding: 18px 20px 20px;
            overflow-y: auto;
        }
        #explorer-content h3 {
            margin: 0;
            font-size: 1rem;
        }
        .explorer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .explorer-hide {
            background: var(--explorer-border);
            color: var(--explorer-text);
            border: none;
            padding: 4px 8px;
            font-size: 0.75rem;
            border-radius: 4px;
            cursor: pointer;
        }
        .explorer-controls {
            display: grid;
            gap: 10px;
            margin-bottom: 12px;
        }
        .explorer-controls label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--explorer-muted);
        }
        .explorer-controls input,
        .explorer-controls select {
            width: 100%;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid var(--explorer-border);
            background: var(--explorer-input-bg);
            color: var(--explorer-input-text);
            font-size: 0.8rem;
        }
        .explorer-controls .explorer-row {
            display: grid;
            gap: 6px;
        }
        .explorer-title-display {
            display: flex;
            gap: 6px;
            align-items: center;
            font-size: 0.8rem;
            color: var(--explorer-muted);
        }
        .explorer-title-display span:last-child {
            color: var(--explorer-text);
            font-weight: 600;
            word-break: break-word;
        }
        .explorer-table {
            width: auto;
            border-collapse: collapse;
            background: var(--explorer-card);
            color: var(--explorer-text);
            font-size: 11px;
            border-radius: 6px;
            overflow: hidden;
            user-select: none;
        }
        .explorer-table.fixed {
            table-layout: fixed;
        }
        .explorer-table th,
        .explorer-table td {
            border: 1px solid var(--explorer-border);
            padding: 4px 6px;
            text-align: left;
            user-select: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .explorer-table th {
            position: relative;
        }
.col-resizer {
    position: absolute;
    right: -5px;
    top: 0;
    width: 15px;
    height: 100%;
    cursor: col-resize;
    background: transparent;
    z-index: 2000;
}
        .col-resizer::after {
            content: "";
            position: absolute;
            right: 4px;
            top: 20%;
            width: 2px;
            height: 60%;
            background: var(--explorer-border);
            border-radius: 1px;
            opacity: 0.7;
        }
        .col-resizer:hover::after {
            background: var(--accent);
            opacity: 1;
        }
        .explorer-col-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }
        .explorer-col-controls label {
            font-size: 0.75rem;
            color: var(--explorer-muted);
        }
        .explorer-col-controls input[type="number"],
        .explorer-col-controls input[type="range"] {
            background: var(--explorer-input-bg);
            color: var(--explorer-input-text);
            border: 1px solid var(--explorer-border);
            border-radius: 4px;
        }
        .explorer-col-controls button {
            background: var(--accent);
            color: var(--button-text);
            border: 1px solid var(--explorer-border);
            border-radius: 6px;
            padding: 6px 8px;
            cursor: pointer;
        }
        .explorer-col-controls button:hover {
            background: var(--accent-2);
        }
        .no-select {
            user-select: none;
        }
        .explorer-table tr:hover td {
            background: var(--explorer-hover);
            cursor: pointer;
        }
        .explorer-selected {
            background: var(--explorer-selected) !important;
        }
        .explorer-menu {
            position: fixed;
            z-index: 3000;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            box-shadow: 0 6px 14px rgba(0,0,0,0.15);
            padding: 6px;
            display: none;
            min-width: 160px;
            color: var(--text);
        }
        .explorer-menu button {
            width: 100%;
            margin: 2px 0;
            padding: 6px 8px;
            font-size: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--accent);
            color: var(--button-text);
            cursor: pointer;
        }
        .explorer-menu button:hover { background: var(--accent-2); }
        .explorer-staged {
            margin-top: 14px;
            border-top: 1px solid var(--explorer-border);
            padding-top: 10px;
        }
        .explorer-staged h4 {
            margin: 0 0 6px 0;
            font-size: 0.85rem;
            color: var(--explorer-muted);
        }
        #explorer-staged-area {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .staged-item {
            flex: 0 0 140px;
        }
        .explorer-staged textarea {
            width: 100%;
            height: 70px;
            font-family: monospace;
            font-size: 11px;
            margin-top: 4px;
            border-radius: 4px;
            border: 1px solid var(--explorer-border);
            background: var(--explorer-card);
            color: var(--explorer-text);
        }
        .explorer-staged-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }
        .explorer-staged-actions button {
            flex: 1;
            padding: 6px 8px;
            font-size: 0.75rem;
            border-radius: 4px;
            border: 1px solid transparent;
            cursor: pointer;
        }
        .explorer-apply { background: var(--accent); color: var(--button-text); }
        .explorer-clear { background: var(--danger); color: #fff; }
        .explorer-staged-actions button:hover { filter: brightness(1.05); }
        .explorer-menu .explorer-menu-row {
            display: flex;
            gap: 6px;
            align-items: center;
            margin-top: 4px;
        }
        .explorer-menu input {
            width: 60px;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid var(--explorer-border);
            background: var(--explorer-input-bg);
            color: var(--explorer-input-text);
            font-size: 0.75rem;
        }
        .explorer-menu select {
            width: 100%;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid var(--explorer-border);
            background: var(--explorer-input-bg);
            color: var(--explorer-input-text);
            font-size: 0.75rem;
        }
        .explorer-send {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 6px;
            margin-top: 10px;
        }
        .explorer-send button {
            padding: 6px 8px;
            font-size: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--explorer-border);
            background: var(--accent);
            color: var(--button-text);
            cursor: pointer;
        }
        .explorer-send .explorer-custom {
            grid-column: span 3;
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .explorer-send .explorer-custom input {
            width: 70px;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid var(--explorer-border);
            background: var(--explorer-input-bg);
            color: var(--explorer-input-text);
            font-size: 0.75rem;
        }
        .explorer-note {
            font-size: 0.75rem;
            color: var(--explorer-muted);
            margin-top: 6px;
        }
        .drop-zone {
            border: 1.5px dashed var(--explorer-border);
            background: var(--explorer-card);
            color: var(--explorer-text);
            border-radius: 8px;
            padding: 14px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
            flex: 0 0 33%;
        }
        .drop-zone:hover, .drop-zone.dragging {
            border-color: var(--accent-2);
            background: var(--explorer-hover);
        }
        .drop-zone .drop-title { font-size: 0.9rem; font-weight: 700; }
        .drop-zone .drop-note { font-size: 0.75rem; color: var(--explorer-muted); margin-top: 6px; }
        .drop-zone .drop-hint { font-size: 0.7rem; color: var(--explorer-muted); margin-top: 4px; }
        .drop-browse {
            margin-top: 10px;
            padding: 6px 10px;
            border: 1px solid var(--explorer-border);
            background: var(--explorer-card);
            color: var(--explorer-text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .drop-browse:hover {
            border-color: var(--accent-2);
        }
        .explorer-top-row {
            display: flex;
            gap: 10px;
            align-items: stretch;
        }
        #explorerFileTree {
            flex: 1;
            background: var(--explorer-bg);
            border: 1px solid var(--explorer-border);
            border-radius: 8px;
            color: var(--explorer-text);
            padding: 10px;
            min-height: 160px;
            overflow: auto;
            user-select: none;
        }
        .tree-note { font-size: 0.8rem; color: var(--explorer-muted); }
        .tree-node { padding-left: 14px; font-size: 0.85rem; line-height: 1.4; }
        .tree-dir, .tree-file { display: flex; align-items: center; gap: 6px; cursor: pointer; }
        .tree-dir:hover, .tree-file:hover { background: var(--explorer-hover); }
        .tree-dir.selected, .tree-file.selected { background: var(--explorer-selected); }
        .tree-toggle { width: 14px; text-align: center; color: var(--explorer-muted); }
        .tree-name { color: var(--explorer-text); }
        .tree-file .tree-name { color: var(--explorer-text); }
        .explorer-preview-wrap {
            max-height: calc(100vh - 260px);
            overflow: auto;
            border: 1px solid var(--explorer-border);
            border-radius: 6px;
            background: var(--explorer-card);
            user-select: none;
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
        }
        #explorer-content::-webkit-scrollbar,
        .explorer-preview-wrap::-webkit-scrollbar,
        #explorerFileTree::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        #explorer-content::-webkit-scrollbar-thumb,
        .explorer-preview-wrap::-webkit-scrollbar-thumb,
        #explorerFileTree::-webkit-scrollbar-thumb {
            background: var(--explorer-border);
            border-radius: 8px;
        }
        #explorer-content::-webkit-scrollbar-track,
        .explorer-preview-wrap::-webkit-scrollbar-track,
        #explorerFileTree::-webkit-scrollbar-track {
            background: var(--explorer-card);
        }
        .bar-width-card { display: none; }
        .bar-width-card .control-item { margin: 0; }
        .bar-draggable { cursor: grab; }
        .bar-draggable.dragging { cursor: grabbing; opacity: 0.8; stroke: #ff69b4; stroke-width: 2; }
        .group-label { cursor: ns-resize; user-select: none; }
        .graph-controls-row {
            grid-column: 2;
            grid-row: 2;
            width: 100%;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 10px;
        }
        .graph-controls-row .legend-panel { margin: 0; width: 100%; box-shadow: none; }
        .axis-label { cursor: move; user-select: none; }
        .theme-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--muted);
        }
        .time-label-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .time-label-item {
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 4px 6px;
            cursor: default;
        }
        .time-label-item input {
            user-select: text;
            -webkit-user-select: text;
        }
        .time-label-item.dragging {
            opacity: 0.6;
        }
        .time-label-drag {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 4px;
            background: var(--panel);
            border: 1px solid var(--border);
            font-size: 12px;
            cursor: grab;
            user-select: none;
        }
        .time-label-drag.dragging {
            cursor: grabbing;
        }
        .time-label-bulk {
            width: 100%;
            min-height: 60px;
            font-family: "SF Mono", monospace;
            font-size: 11px;
            border-radius: 6px;
            border: 1px solid var(--input-border);
            background: var(--input-bg);
            color: var(--input-text);
            padding: 6px;
        }
        .time-label-item input {
            width: 90px;
            font-size: 0.8rem;
        }
        .time-label-remove {
            border: none;
            background: var(--danger);
            color: #fff;
            border-radius: 4px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            font-size: 10px;
            line-height: 1;
        }
        .group-time-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-top: 8px;
        }
        .group-time-col label {
            font-size: 0.75rem;
            color: var(--muted);
            display: block;
            margin-bottom: 4px;
        }
        .group-time-col textarea {
            width: 100%;
            height: 70px;
            font-family: "SF Mono", monospace;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--input-border);
            background: var(--input-bg);
            color: var(--input-text);
        }
        .option-list label,
        .legend-row label,
        .control-item label {
            color: var(--text) !important;
        }
        html[data-theme="dark"] .master-label-card {
            background: var(--card) !important;
            border-color: var(--border) !important;
            color: var(--text);
        }
        html[data-theme="dark"] .control-card h4,
        html[data-theme="dark"] label,
        html[data-theme="dark"] .legend-row label,
        html[data-theme="dark"] .option-list label,
        html[data-theme="dark"] .control-item,
        html[data-theme="dark"] .ymax-pos {
            color: var(--text);
        }
        html[data-theme="dark"] .legend-panel,
        html[data-theme="dark"] .panel,
        html[data-theme="dark"] .stats-panel,
        html[data-theme="dark"] .code-board {
            background: var(--panel);
            border-color: var(--border);
        }
    </style>
</head>
<body>

<div id="explorer-panel">
    <div id="explorer-handle" title="Explorer">⋮</div>
    <div id="explorer-content">
        <div class="explorer-header">
            <h3>Explorer</h3>
        </div>
        <div class="explorer-controls">
            <div class="explorer-top-row">
                <div class="drop-zone" id="explorerDropZone">
                    <div class="drop-title">Drag & Drop local files or folders</div>
                    <div class="drop-note">Local-only loading; no upload.</div>
                    <div class="drop-hint">Drop CSV / TSV / XLSX / XLS here</div>
                    <button type="button" class="drop-browse" onclick="document.getElementById('explorerDirInput').click()">or select from local</button>
                </div>
                <div id="explorerFileTree">
                    <div class="tree-note">Drop a folder to show its tree here.</div>
                </div>
            </div>
            <input type="file" id="explorerDirInput" webkitdirectory style="display:none;">
            <div>
                <label for="explorerFileList">Select From Folder (local)</label>
                <select id="explorerFileList">
                    <option value="">No file selected</option>
                </select>
            </div>
            <div>
                <label for="explorerSheetSelect">Sheet</label>
                <select id="explorerSheetSelect" disabled>
                    <option value="">No sheet</option>
                </select>
            </div>
            <div>
                <label for="explorerMode">Mode</label>
                <select id="explorerMode" class="text-input">
                    <option value="time">Time Series Mode</option>
                    <option value="comparison">Comparison Mode</option>
                    <option value="survival">Survival Mode</option>
                    <option value="longitudinal">Longitudinal State-Space Mode</option>
                </select>
            </div>
            <small class="explorer-note">Files stay local; nothing is uploaded.</small>
        </div>
        <div id="explorer-preview-area">
            <p class="explorer-note">Select a local file to preview (読み込みのみで端末から外へ送信されません)。Drag to select cells, then stage to a group.</p>
        </div>
        <div class="explorer-staged">
            <h4>Staged Group Data</h4>
            <div class="explorer-title-display">
                <span>Title:</span>
                <span id="explorerTitleDisplay">-</span>
            </div>
            <div id="explorer-staged-area"></div>
            <div class="explorer-staged-actions">
                <button type="button" class="explorer-apply" onclick="applyStagedGroups()">Send to Main</button>
                <button type="button" class="explorer-apply" onclick="addExplorerGroup()">Add Group</button>
                <button type="button" class="explorer-apply" onclick="saveExplorerStash()">Save Staged</button>
                <button type="button" class="explorer-apply" onclick="loadExplorerStash()">Load Staged</button>
                <button type="button" class="explorer-clear" onclick="clearStagedGroups()">Clear</button>
            </div>
        </div>
        <button type="button" class="explorer-hide" id="explorerHideBtn" style="margin-top: 12px; width: 100%;">Hide</button>
    </div>
</div>
<div id="explorerMenu" class="explorer-menu">
    <div id="explorerGroupButtons"></div>
    <button type="button" id="explorerAddGroupBtn">+ Add Group</button>
    <div class="explorer-menu-row">
        <span style="font-size:0.7rem; color: var(--muted);">Group #</span>
        <input type="number" id="explorerGroupIndexMenu" min="1" value="4">
        <button type="button" style="width:auto; padding:4px 8px;" onclick="sendExplorerToGroup()">Stage</button>
    </div>
    <div class="explorer-menu-row" id="explorerTimeActions">
        <button type="button" style="width:auto; padding:4px 8px;" onclick="stageExplorerTimeLabels(true)">Set Time Labels</button>
        <button type="button" style="width:auto; padding:4px 8px;" onclick="stageExplorerTimeLabels(false)">Append Time Labels</button>
    </div>
    <div class="explorer-menu-row" id="explorerTimeTargetRow">
        <span style="font-size:0.7rem; color: var(--muted);">Time</span>
        <select id="explorerTimeIndexMenu"></select>
    </div>
    <button type="button" onclick="sendExplorerToTitle()">Send to Title</button>
</div>

<div class="container">
    <div class="panel input-area" id="leftPanel">
        <div class="master-label-card">
            <label style="margin-bottom:6px;">Theme</label>
            <select id="themeSelect" class="text-input" aria-label="Theme">
                <option value="system">System</option>
                <option value="light">Light</option>
                <option value="dark">Dark</option>
            </select>
        </div>
        <h3 style="margin-top:0;">1. Time Points / Labels</h3>
        <div class="master-label-card" style="margin-bottom: 20px;">
            <label style="display: block; font-weight: bold; color: #d9480f; margin-bottom: 6px;">Mode</label>
            <select id="plotMode" class="text-input" onchange="setPlotMode()">
                <option value="time">Time Series Mode</option>
                <option value="comparison" selected>Comparison Mode</option>
                <option value="survival">Survival Mode</option>
                <option value="longitudinal">Longitudinal State-Space Mode</option>
            </select>
        </div>
        <div class="master-label-card">
            <label style="margin-bottom:6px;">Load Sample Data</label>
            <div style="display:flex; gap:8px;">
                <button type="button" class="btn-add" style="margin:0;" onclick="loadSampleTimeline()">Time Series Sample</button>
                <button type="button" class="btn-add" style="margin:0;" onclick="loadSampleComparison()">Two-Group Sample</button>
                <button type="button" class="btn-add" style="margin:0;" onclick="loadSampleSurvival()">Survival Sample</button>
                <button type="button" class="btn-add" style="margin:0;" onclick="loadSampleLongitudinal()">Longitudinal State-Space Template</button>
            </div>
        </div>
        <div class="master-label-card" id="timeSeriesSection">
            <label>Shared Time Labels</label>
            <div id="timeLabelList" class="time-label-list"></div>
            <button type="button" class="btn-mini" id="addTimeLabelBtn" style="width:auto; margin-top:6px;">+ Time</button>
            <input type="text" id="timePointsInput" class="text-input" value="Day1 Day3 Day7" style="display:none;">
            <div style="margin-top:8px;">
                <label style="font-size:0.75rem; color: var(--muted);">Bulk edit (space/tab/newline separated)</label>
                <textarea id="timeLabelsBulk" class="time-label-bulk" placeholder="Day1 Day3 Day7"></textarea>
                <button type="button" class="btn-mini" style="width:auto; margin-top:6px;" onclick="applyTimeLabelsBulk()">Apply</button>
            </div>
        </div>
        <div class="master-label-card" id="longitudinalSection" style="display:none;">
            <label style="margin-bottom:6px;">Longitudinal State-Space Inputs</label>
            <div style="display:grid; gap:8px;">
                <div>
                    <label style="font-size:0.75rem; color: var(--muted);">Raw CSV (id/group/time/y)</label>
                    <input type="file" id="longitudinalRawInput" accept=".csv">
                </div>
                <div>
                    <label style="font-size:0.75rem; color: var(--muted);">Posterior Draws (JSON)</label>
                    <input type="file" id="longitudinalPosteriorInput" accept=".json">
                </div>
                <div style="display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:6px;">
                    <div>
                        <label style="font-size:0.7rem; color: var(--muted);">id column</label>
                        <input type="text" id="longitudinalIdCol" class="text-input" value="id">
                    </div>
                    <div>
                        <label style="font-size:0.7rem; color: var(--muted);">group column</label>
                        <input type="text" id="longitudinalGroupCol" class="text-input" value="group">
                    </div>
                    <div>
                        <label style="font-size:0.7rem; color: var(--muted);">time column</label>
                        <input type="text" id="longitudinalTimeCol" class="text-input" value="time">
                    </div>
                    <div>
                        <label style="font-size:0.7rem; color: var(--muted);">y column</label>
                        <input type="text" id="longitudinalYCol" class="text-input" value="y">
                    </div>
                </div>
                <div id="longitudinalStatus" style="font-size:0.75rem; color: var(--muted);"></div>
            </div>
        </div>

        <div id="groupDataSection">
            <h3>2. Group Data</h3>
            <div style="display:flex; align-items:center; gap:8px; margin: 6px 0 12px;">
                <label style="margin:0;">Graph Title</label>
                <input type="text" id="chartTitleInput" class="text-input" placeholder="Title" oninput="syncChartTitle()" style="width:100px;">
                <input type="number" id="titleFontSize" value="10" oninput="updatePlot()" style="width:50px;" aria-label="Title font size">
                <label style="font-weight: normal; font-size: 0.75rem; color: var(--muted); display:flex; align-items:center; gap:4px; margin:0;">
                    <input type="checkbox" id="titleItalic" onchange="updatePlot()">
                    Italic
                </label>
            </div>
            <div id="groupsContainer">
                </div>
            <button class="btn-add" onclick="addNewGroup()">+ Add New Group</button>
        </div>
        <div class="master-label-card" style="margin-top: 15px;">
            <label style="margin-bottom:6px;">Axis Labels</label>
            <div style="display:grid; gap:6px;">
                <input type="text" id="xAxisLabel" class="text-input" placeholder="X-axis label" oninput="updatePlot()">
                <div style="display:flex; gap:6px; align-items:center;">
                    <span style="font-size:0.75rem; color: var(--muted);">X距離</span>
                    <button type="button" class="btn-mini" onclick="adjustLabelOffset('xLabelOffset', -2)">←</button>
                    <input type="number" id="xLabelOffset" value="25" oninput="updatePlot()" style="width:50px;">
                    <button type="button" class="btn-mini" onclick="adjustLabelOffset('xLabelOffset', 2)">→</button>
                    <span style="font-size:0.75rem; color: var(--muted); margin-left:6px;">Font</span>
                    <input type="number" id="xAxisFontSize" value="10" oninput="updatePlot()" style="width:50px;">
                </div>
                <input type="text" id="yAxisLabel" class="text-input" placeholder="Y-axis label" oninput="updatePlot()">
                <div style="display:flex; gap:6px; align-items:center;">
                    <span style="font-size:0.75rem; color: var(--muted);">Y距離</span>
                    <button type="button" class="btn-mini" onclick="adjustLabelOffset('yLabelOffset', -2)">←</button>
                    <input type="number" id="yLabelOffset" value="25" oninput="updatePlot()" style="width:50px;">
                    <button type="button" class="btn-mini" onclick="adjustLabelOffset('yLabelOffset', 2)">→</button>
                    <span style="font-size:0.75rem; color: var(--muted); margin-left:6px;">Font</span>
                    <input type="number" id="yAxisFontSize" value="10" oninput="updatePlot()" style="width:50px;">
                </div>
            </div>
        </div>
        <div class="master-label-card" id="survivalSection" style="margin-top: 15px; display:none;">
            <label style="margin-bottom:6px; display:flex; gap:8px; align-items:center;">
                Survival Mode (Kaplan-Meier)
            </label>
            <textarea id="survivalData" placeholder="Group[TAB]Sample[TAB]Day of death" oninput="updatePlot()" style="height: 90px;"></textarea>
            <div style="display:flex; gap:6px; align-items:center; margin-top:6px;">
                <span style="font-size:0.75rem; color: var(--muted);">X Max</span>
                <input type="number" id="survivalXMax" value="0" min="0" oninput="this.dataset.auto='false'; updatePlot()" style="width:70px;">
                <small style="color: var(--muted);">0=Auto</small>
            </div>
            <div style="display:flex; gap:12px; align-items:center; margin-top:6px; flex-wrap: wrap;">
                <label style="font-size:0.75rem; color: var(--muted);"><input type="checkbox" id="survivalYAxisPercent" onchange="updatePlot()"> Y-axis %</label>
            </div>
            <small style="color: var(--muted);">Format: Group, Sample, Day (tab-separated)</small>
        </div>
        <div style="margin-top: 30px; border-top: 1px solid #ddd; padding-top: 15px;">
            <details open style="font-size: 0.85rem; color: #444; cursor: pointer;">
                <summary style="font-weight: bold; margin-bottom: 10px; color: #d9480f;">⚠EEUsage Notes & Disclaimer</summary>
                <div style="background: #fffcf0; padding: 12px; border: 1px solid #ffe8cc; border-radius: 8px; line-height: 1.6;">
                    <strong>Purpose</strong><br>
                    This tool is designed for rapid visualization of raw spreadsheet data, with the primary goal of <strong>checking dot distributions and overall trends at a glance</strong>.<br><br>
                    
                    <strong>Statistical Results</strong><br>
                    Reported p-values and significance flags are approximate. <strong>For theses or publications, always verify final statistics using dedicated software (GraphPad Prism, R, etc.).</strong><br><br>
                    
                    <small style="color: var(--muted);">
                        By using this tool, you acknowledge that the developer assumes no liability for decisions made from its output. Final scientific judgment remains the user's responsibility.
                    </small>
                    
                    <div style="margin-top: 12px; font-size: 0.75rem; border-top: 1px dashed var(--border); padding-top: 8px; text-align: right;">
                        © 2024-2026 Michito Hamada.
                    </div>
                </div>
            </details>
        </div>
    </div>

    <div class="resizer" id="resizerHandle"></div>

    <div class="main-content">
        <div class="preview-row">
            <div class="preview-wrapper">
                <div style="grid-column: 1; grid-row: 1; display: flex; flex-direction: column; align-items: center; gap: 6px;">
                    <label style="font-size: 0.75rem; color: var(--muted); display: flex; align-items: center; gap: 6px;">
                        H:
                        <input type="number" id="chartHeightVal" value="200" min="200" max="800" oninput="syncChartSize('height')" style="width: 60px; padding: 2px 4px;">
                    </label>
                </div>
                <div id="svg-wrapper">
                    <div id="svg-container"></div>
                    <div class="resize-handle resize-tl" data-handle="tl"></div>
                    <div class="resize-handle resize-tr" data-handle="tr"></div>
                    <div class="resize-handle resize-bl" data-handle="bl"></div>
                    <div class="resize-handle resize-br" data-handle="br"></div>
                    <div class="handle-pos" id="handlePosLeft" style="left: 6px; top: -18px;">L: 0</div>
                    <div style="position:absolute; right:-220px; top: 6px; width: 210px; font-size: 0.75rem; color: var(--muted); line-height: 1.4;">
                        Tip: Drag the title, Y-axis label, and legend to reposition.
                    </div>
                </div>
                <div class="graph-controls-row">
                    <div class="panel legend-panel" id="lineOptionsCard">
                        <div class="option-list">
                            <label style="font-weight: normal;"><input type="checkbox" id="showLines" onchange="updatePlot()"> Show Lines</label>
                            <label style="font-weight: normal;"><input type="checkbox" id="showBars" onchange="handleShowBarsToggle()" checked> Show Bars</label>
                        </div>
                        <div class="option-list" id="lineOptionsBody">
                            <label style="font-weight: normal;"><input type="checkbox" id="showSampleLines" onchange="updatePlot()"> Sample Lines</label>
                            <label style="font-weight: normal;"><input type="checkbox" id="showMean" onchange="updatePlot()" checked> Mean Line / Dots</label>
                            <label style="font-weight: normal;"><input type="checkbox" id="showMeanDots" onchange="updatePlot()" checked> Mean Dots (Line Mode)</label>
                            <label style="font-weight: normal;"><input type="checkbox" id="showErrorBars" onchange="updatePlot()" checked> Error Bars</label>
                        </div>
                    </div>
                    <div class="panel legend-panel bar-width-card" id="barWidthCard">
                        <div class="control-item">
                            <label for="barWidthSlider">Bar Width</label>
                            <input type="range" id="barWidthSlider" min="6" max="80" value="28" oninput="syncBarWidthFromSlider()">
                            <div style="font-size:0.8rem; color: var(--muted);">Current: <span id="barWidthValue">28</span> px</div>
                        </div>
                        <div style="display:flex; gap:8px; flex-wrap:wrap;">
                            <button type="button" class="btn-mini" style="width:auto;" onclick="resetBarPositions()">Reset Bar Positions</button>
                            <button type="button" class="btn-mini" style="width:auto;" onclick="undoBarChanges()">Undo</button>
                            <button type="button" class="btn-mini" style="width:auto;" onclick="redoBarChanges()">Redo</button>
                        </div>
                    </div>
                    <div class="panel legend-panel">
                        <div class="option-list">
                            <label style="font-weight: normal;"><input type="checkbox" id="showPostHoc" onchange="updatePlot()"> Show Post-hoc (Dunnett)</label>
                            <label style="font-weight: normal;"><input type="checkbox" id="autoBrackets" onchange="updatePlot()" checked> Auto Brackets (*)</label>
                        </div>
                        <div class="control-item">
                            <label>Bracket Offset <span id="bracketOffsetVal" style="font-weight: normal; color: var(--muted);">center</span></label>
                            <input type="range" id="bracketOffset" min="-60" max="120" value="0" oninput="updatePlot()">
                        </div>
                    </div>
                    <div class="panel legend-panel">
                        <div class="card-grid-2">
                            <div class="control-item">
                                <label for="fontSizeX">Font (X)</label>
                                <input type="number" id="fontSizeX" value="10" oninput="updatePlot()">
                            </div>
                            <div class="control-item">
                                <label for="dotSize">Dot Size</label>
                                <div class="compact-row">
                                    <input type="number" id="dotSize" min="0.1" max="15" step="0.1" value="3.0" oninput="updatePlot()">
                                </div>
                            </div>
                            <div class="control-item">
                                <label for="fontSizeY">Font (Y)</label>
                                <input type="number" id="fontSizeY" value="10" oninput="updatePlot()">
                            </div>
                            <div class="control-item">
                                <label for="jitter">Dot Jitter</label>
                                <div class="compact-row">
                                    <input type="number" id="jitter" min="0" max="40" value="8" oninput="updatePlot()">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="panel legend-panel panel-tight">
                        <h4 style="margin:0 0 6px 0; font-size:0.9rem; color: var(--muted);">Y-Axis</h4>
                        <div class="ymax-inline" style="align-items:flex-end;">
                            <div class="control-item" style="min-width:70px;">
                                <label for="yMinInput">Y-Min</label>
                                <input type="number" id="yMinInput" value="0" data-auto="true" oninput="updatePlot()" aria-label="Y minimum">
                            </div>
                            <div class="control-item" style="min-width:70px;">
                                <label for="yMaxInput">Y-Max</label>
                                <input type="number" id="yMaxInput" value="0" data-auto="true" oninput="this.dataset.auto='false'; updatePlot();" aria-label="Y maximum">
                            </div>
                            <button type="button" class="btn-mini" style="width:auto;" onclick="setAutoYMax()">Auto</button>
                        </div>
                        <div class="control-item">
                            <label for="numTicks">Ticks</label>
                            <input type="number" id="numTicks" value="5" min="2" max="12" oninput="updatePlot()">
                        </div>
                        <div class="control-item">
                            <label style="margin-bottom:2px;">Error Bar</label>
                            <input type="hidden" id="errorType" value="se">
                            <div class="error-toggle">
                                <button type="button" id="err-sem" class="btn-mini active" style="width:auto;" onclick="setErrorType('se')">SEM</button>
                                <button type="button" id="err-sd" class="btn-mini" style="width:auto;" onclick="setErrorType('sd')">SD</button>
                            </div>
                        </div>
                    </div>
                    <div class="panel legend-panel">
                        <div class="control-item">
                            <label style="font-weight: normal; margin: 0;"><input type="checkbox" id="showLegend" checked onchange="updatePlot()"> Show Legend</label>
                        </div>
                        <input type="hidden" id="legendState" value="95,10">
                        <div class="legend-row">
                            <label for="legendFontSize">Font</label>
                            <input type="number" id="legendFontSize" value="10" oninput="updatePlot()" class="legend-input">
                        </div>
                    </div>
                </div>
                <div style="grid-column: 2; grid-row: 3; display: flex; align-items: center; gap: 10px; justify-self: start;">
                    <label style="font-size: 0.75rem; color: var(--muted); display: flex; align-items: center; gap: 6px;">
                        W:
                        <input type="number" id="chartWidthVal" value="300" min="10" max="1000" oninput="syncChartSize('width')" style="width: 60px; padding: 2px 4px;">
                    </label>
                </div>
                <div style="grid-column: 2; grid-row: 4; width: 100%; display: flex; gap: 8px; justify-content: flex-start; justify-self: start; flex-wrap: wrap;">
                    <input type="text" id="exportFileName" class="text-input" value="MultiGroup_Figure" style="width:180px;" aria-label="Export file name">
                    <select id="exportFormat" class="text-input" style="width:110px;">
                        <option value="svg">SVG</option>
                        <option value="png">PNG</option>
                        <option value="pdf">PDF</option>
                        <option value="tif">TIF</option>
                    </select>
                    <button class="btn-dl btn-small" onclick="saveCurrentFigure()">Save Figure</button>
                    <button class="btn-dl btn-small" onclick="chooseExportDirectory()" style="background:#6c757d;">Pick Folder</button>
                    <button class="btn-dl btn-small" onclick="copySvgToClipboard()" style="background:#007bff;">Copy SVG (for Illustrator or Affinity)</button>
                    <div style="flex-basis:100%; font-size:0.75rem; color: var(--muted);" id="exportPathLabel">Path: Browser download</div>
                </div>
                <div style="grid-column: 2; grid-row: 5; width: 100%; justify-self: start;">
                    <div class="config-profile">
                        <div class="config-title">Configuration Profile</div>
                        <div class="config-actions">
                            <button type="button" class="btn-profile" onclick="downloadProfile()">Download (JSON)</button>
                            <button type="button" class="btn-profile" onclick="document.getElementById('profileInput').click()">Load</button>
                            <button type="button" class="btn-profile" onclick="resetProfile()">Reset</button>
                            <input type="file" id="profileInput" accept="application/json" style="display:none;" onchange="loadProfile(event)">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="longitudinal-area" id="longitudinalArea">
            <div class="longitudinal-plot-card">
                <div class="longitudinal-plot-header">
                    <div>Time-course (mode + credible interval band)</div>
                    <div class="longitudinal-actions">
                        <button class="longitudinal-btn" type="button" data-longitudinal-export="longitudinalTimePlot" data-format="svg">Download SVG</button>
                        <button class="longitudinal-btn" type="button" data-longitudinal-export="longitudinalTimePlot" data-format="png">Download PNG</button>
                        <button class="longitudinal-btn" type="button" data-longitudinal-export="longitudinalTimePlot" data-format="pdf">Download PDF</button>
                        <button class="longitudinal-btn" type="button" data-longitudinal-export="longitudinalTimePlot" data-format="tif">Download TIF</button>
                        <button class="longitudinal-btn" type="button" id="longitudinalTimeReset">Reset</button>
                    </div>
                </div>
                <div class="longitudinal-size-row" style="margin-bottom:8px;">
                    <span style="font-size:0.75rem; color: var(--muted);">Size</span>
                    <input type="number" id="longitudinalTimeWidth" value="900" min="300">
                    <input type="number" id="longitudinalTimeHeight" value="360" min="200">
                </div>
                <div class="longitudinal-svg-wrapper" id="longitudinalTimeWrapper" style="border:1px solid var(--border); border-radius:8px; padding:4px; background: var(--svg-bg);">
                    <svg id="longitudinalTimePlot" viewBox="0 0 900 360" preserveAspectRatio="xMidYMid meet"></svg>
                    <div class="longitudinal-handle tl" data-target="time" data-handle="tl"></div>
                    <div class="longitudinal-handle tr" data-target="time" data-handle="tr"></div>
                    <div class="longitudinal-handle bl" data-target="time" data-handle="bl"></div>
                    <div class="longitudinal-handle br" data-target="time" data-handle="br"></div>
                </div>
                <div id="longitudinalTimeLegend" class="legend-row" style="font-size:0.75rem; color: var(--muted); flex-wrap: wrap;"></div>
            </div>
            <div class="longitudinal-plot-card">
                <div class="longitudinal-plot-header">
                    <div>Difference posterior density (vs control)</div>
                    <div class="longitudinal-actions">
                        <button class="longitudinal-btn" type="button" data-longitudinal-export="longitudinalDiffPlot" data-format="svg">Download SVG</button>
                        <button class="longitudinal-btn" type="button" data-longitudinal-export="longitudinalDiffPlot" data-format="png">Download PNG</button>
                        <button class="longitudinal-btn" type="button" data-longitudinal-export="longitudinalDiffPlot" data-format="pdf">Download PDF</button>
                        <button class="longitudinal-btn" type="button" data-longitudinal-export="longitudinalDiffPlot" data-format="tif">Download TIF</button>
                        <button class="longitudinal-btn" type="button" id="longitudinalDiffReset">Reset</button>
                    </div>
                </div>
                <div class="longitudinal-size-row" style="margin-bottom:8px;">
                    <span style="font-size:0.75rem; color: var(--muted);">Size</span>
                    <input type="number" id="longitudinalDiffWidth" value="900" min="300">
                    <input type="number" id="longitudinalDiffHeight" value="360" min="200">
                </div>
                <div class="longitudinal-svg-wrapper" id="longitudinalDiffWrapper" style="border:1px solid var(--border); border-radius:8px; padding:4px; background: var(--svg-bg);">
                    <svg id="longitudinalDiffPlot" viewBox="0 0 900 360" preserveAspectRatio="xMidYMid meet"></svg>
                    <div class="longitudinal-handle tl" data-target="diff" data-handle="tl"></div>
                    <div class="longitudinal-handle tr" data-target="diff" data-handle="tr"></div>
                    <div class="longitudinal-handle bl" data-target="diff" data-handle="bl"></div>
                    <div class="longitudinal-handle br" data-target="diff" data-handle="br"></div>
                </div>
                <div id="longitudinalDiffLegend" class="legend-row" style="font-size:0.75rem; color: var(--muted); flex-wrap: wrap;"></div>
            </div>
            <div class="longitudinal-plot-card">
                <div class="longitudinal-plot-header">
                    <div>Longitudinal Controls</div>
                </div>
                <div style="display:grid; gap:10px; grid-template-columns: repeat(3, minmax(0, 1fr));">
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">Control group</label>
                        <select id="longitudinalControlSelect" class="text-input"></select>
                    </div>
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">Credible Interval</label>
                        <input type="range" id="longitudinalCiSlider" min="0.5" max="0.99" step="0.01" value="0.9"
                            title="Credible interval is a Bayesian posterior interval; adjusting it changes the uncertainty band/lines without changing the fitted model.">
                        <div id="longitudinalCiReadout" style="font-size:0.8rem; color: var(--muted); margin-top:4px;"
                            title="Credible interval is a Bayesian posterior interval; adjusting it changes the uncertainty band/lines without changing the fitted model."></div>
                    </div>
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">Time points</label>
                        <div id="longitudinalTimeChecklist" class="option-list" style="max-height:140px; overflow:auto;"></div>
                    </div>
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">Groups (non-control)</label>
                        <div id="longitudinalGroupChecklist" class="option-list" style="max-height:140px; overflow:auto;"></div>
                    </div>
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">Legend font size</label>
                        <input type="number" id="longitudinalLegendSize" value="11" min="6" max="24">
                    </div>
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">Axis line width</label>
                        <input type="number" id="longitudinalAxisWidth" value="1" min="1" max="6">
                    </div>
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">Curve line width</label>
                        <input type="number" id="longitudinalLineWidth" value="2" min="1" max="6">
                    </div>
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">CI line width</label>
                        <input type="number" id="longitudinalCiLineWidth" value="2" min="1" max="6">
                    </div>
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">Time-course Y Min/Max</label>
                        <div class="longitudinal-size-row">
                            <input type="number" id="longitudinalTimeYMin" placeholder="auto">
                            <input type="number" id="longitudinalTimeYMax" placeholder="auto">
                            <button type="button" class="btn-mini" id="longitudinalTimeYAuto">Auto</button>
                        </div>
                        <input type="range" id="longitudinalTimeYMinSlider" min="0" max="100" value="0">
                        <input type="range" id="longitudinalTimeYMaxSlider" min="0" max="100" value="100">
                    </div>
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">Difference X Min/Max</label>
                        <div class="longitudinal-size-row">
                            <input type="number" id="longitudinalDiffXMin" placeholder="auto">
                            <input type="number" id="longitudinalDiffXMax" placeholder="auto">
                            <button type="button" class="btn-mini" id="longitudinalDiffXAuto">Auto</button>
                        </div>
                        <input type="range" id="longitudinalDiffXMinSlider" min="0" max="100" value="0">
                        <input type="range" id="longitudinalDiffXMaxSlider" min="0" max="100" value="100">
                    </div>
                    <div>
                        <label style="font-size:0.75rem; color: var(--muted);">Group colors</label>
                        <div id="longitudinalColorList" class="longitudinal-color-list"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="stats-panel">
            <h3>3. Statistical Analysis Board</h3>
            <div id="statsTableContainer">
                <p style="color: var(--muted);">チEEタをE力すると、各タイムポイントごとの検定結果がここに表示されます、E/p>
            </div>
            <div style="margin-top: 10px; display: flex; gap: 8px; flex-wrap: wrap;">
                <button class="btn-dl btn-small" onclick="downloadCSV()" style="background:#6c757d;">Download CSV</button>
                <button class="btn-dl btn-small" onclick="downloadStatsCode()" style="background:#6c757d;">Download Statistical Code for R</button>
            </div>
        </div>

        <div class="stats-panel">
            <h3>4. Calculation Details</h3>
            <div class="code-board" id="calcDetails" style="background:#f8f9fb; color:#333; white-space:pre-wrap;"></div>
        </div>

        <div class="stats-panel">
            <h3>5. Statistical Methods & Source Code</h3>
            <div class="code-board" id="codeDisplay">// 統計アルゴリズムを表示中...</div>
        </div>
    </div>
<div id="toast" class="toast">Copied</div>
</div>

<script>
let groupCount = 0;
const defaultColors = ['#ffffff', '#ffcccc', '#ccffcc', '#ccccff', '#ffffcc', '#ffccff'];
let plotMetrics = null;
let chartOffsetX = 0;
let chartOffsetY = 0;
let activeProfile = null;
let exportDirectoryHandle = null;
let exportDirectoryName = '';
let explorerData = null;
let explorerSelectedCol = -1;
let explorerSelecting = false;
let explorerSelection = null;
let explorerFiles = [];
let stagedGroups = {};
let stagedTimeLabels = [];
let explorerColWidths = [];
let explorerColRecommendedWidths = [];
let explorerColHardMinWidths = [];
const explorerColMinWidth = 10;
const explorerColMaxWidth = 800;
const explorerColDefaultWidth = 120;
const explorerColStorageKey = 'csvPreviewColWidths';
const explorerHideDecimalsKey = 'csvPreviewHideDecimals';
let explorerHideDecimals = null;
const longitudinalState = {
    raw: null,
    draws: null,
    groups: [],
    times: [],
    controlIdx: 0,
    ci: 0.9,
    caches: null,
    source: null,
    colors: [],
    legendFontSize: 11,
    axisStrokeWidth: 1,
    lineWidth: 2,
    ciLineWidth: 2,
    axisRanges: {
        time: { auto: true, min: null, max: null, autoMin: null, autoMax: null },
        diff: { auto: true, min: null, max: null, autoMin: null, autoMax: null }
    },
    sizes: {
        time: { width: 900, height: 360 },
        diff: { width: 900, height: 360 }
    },
    offsets: {
        time: { x: 0, y: 0 },
        diff: { x: 0, y: 0 }
    }
};
const explorerMinBase = 10;
const explorerMinCharPx = 7;
const explorerMinFloor = 10;
const explorerMinCeil = 380;
const explorerMinFloorFirst = 10;
const explorerHardMinWidth = 10;
const explorerHardMinWidthFirst = 10;
const explorerMinSampleRows = 30;
let explorerOpenedOnce = false;
let explorerWorkbook = null;
let explorerSheetName = null;
let explorerLastPointer = { x: 0, y: 0 };
let explorerDocMouseUpHandlerAdded = false;
let stagedGroupNames = {};
let explorerTreeState = {};
let barWidthState = 28;
let groupOffsetX = [];
let groupLabelOffsetY = [];
let titleOffsetX = 0;
let titleOffsetY = 0;
let xAxisLabelOffsetX = 0;
let xAxisLabelOffsetY = 0;
let yAxisLabelOffsetX = 0;
let yAxisLabelOffsetY = 0;
let undoStack = [];
let redoStack = [];
let draggingBarIndex = null;
let draggingStartOffset = 0;
let draggingBarStartX = 0;
let draggingGroupLabelIndex = null;
let draggingGroupLabelStartY = 0;
let draggingGroupLabelStartOffset = 0;
let draggingAxisLabel = null;
let draggingAxisLabelStartX = 0;
let draggingAxisLabelStartY = 0;
let draggingAxisLabelStartOffsetX = 0;
let draggingAxisLabelStartOffsetY = 0;
let autoBottomPad = 0;
let targetBottomPad = 0;
let stableZeroSince = null;
let lastGrowAt = 0;
const NEVER_SHRINK = true;
let updateRafScheduled = false;

function addNewGroup(name = "", color = "", data = "") {
    groupCount++;
    const id = `group_${groupCount}`;
    const container = document.getElementById('groupsContainer');
    const colorVal = color || defaultColors[(groupCount - 1) % defaultColors.length];
    const nameVal = name || (groupCount === 1 ? "WT" : groupCount === 2 ? "KO" : `Drug ${groupCount - 2}`);

    const card = document.createElement('div');
    card.className = 'group-card';
    card.id = id;
    card.innerHTML = `
        <button class="btn-remove" onclick="removeGroup('${id}')">×</button>
        <div class="group-header">
            <input type="text" class="group-name-input" value="${nameVal}" style="width:100px" oninput="updatePlot()">
            <input type="color" class="group-color-input" value="${colorVal}" oninput="updatePlot()">
            <button type="button" class="btn-mini" style="width:auto;" onclick="toggleGroupBulkEdit('${id}')">Bulk Edit</button>
        </div>
        <div class="group-time-grid" style="display:none;"></div>
        <textarea class="group-data-input" placeholder="Paste data here..." oninput="handlePaste('${id}')">${data}</textarea>
        <div class="paste-preview"></div>
    `;
    container.appendChild(card);
    if (getExplorerMode() === 'time') {
        renderGroupTimeGrid(card);
    }
    updatePlot();
}

function parseDelimitedText(text) {
    const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
    const nonEmpty = lines.filter(l => l.trim() !== '');
    if (nonEmpty.length === 0) return [];
    const sample = nonEmpty[0];
    const delim = sample.includes('\t') ? '\t' : ',';
    return nonEmpty.map(line => line.split(delim));
}

function updateExplorerFileList(files) {
    const list = document.getElementById('explorerFileList');
    if (!list) return;
    list.innerHTML = '<option value=\"\">Select a file</option>';
    files.forEach((file, idx) => {
        const opt = document.createElement('option');
        opt.value = String(idx);
        opt.textContent = file.webkitRelativePath || file.name;
        list.appendChild(opt);
    });
}

function updateExplorerSheetList(sheetNames) {
    const select = document.getElementById('explorerSheetSelect');
    if (!select) return;
    select.innerHTML = '';
    if (!sheetNames || sheetNames.length === 0) {
        select.innerHTML = '<option value=\"\">No sheet</option>';
        select.disabled = true;
        return;
    }
    sheetNames.forEach((name, idx) => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name || `Sheet ${idx + 1}`;
        select.appendChild(opt);
    });
    select.disabled = false;
}

function loadExplorerSheet(name) {
    if (!explorerWorkbook || !name) return;
    explorerSheetName = name;
    const sheet = explorerWorkbook.Sheets[name];
    explorerData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    explorerSelectedCol = -1;
    explorerSelection = null;
    hideExplorerMenu();
    renderStagedGroups();
    renderExplorerPreview();
}

function readExplorerFile(file) {
    if (!file) return;
    const ext = file.name.toLowerCase();
    const reader = new FileReader();
    reader.onload = (evt) => {
        if (ext.endsWith('.xlsx') || ext.endsWith('.xls')) {
            const data = evt.target.result;
            explorerWorkbook = XLSX.read(data, { type: 'binary' });
            updateExplorerSheetList(explorerWorkbook.SheetNames || []);
            const first = explorerWorkbook.SheetNames[0];
            if (first) {
                loadExplorerSheet(first);
            }
            return;
        } else {
            explorerWorkbook = null;
            updateExplorerSheetList([]);
            const text = evt.target.result;
            explorerData = parseDelimitedText(text);
        }
        explorerSelectedCol = -1;
        explorerSelection = null;
        hideExplorerMenu();
        renderStagedGroups();
        renderExplorerPreview();
    };
    if (ext.endsWith('.xlsx') || ext.endsWith('.xls')) {
        reader.readAsBinaryString(file);
    } else {
        reader.readAsText(file);
    }
}

function collectDroppedFiles(dataTransfer) {
    return new Promise((resolve) => {
        if (!dataTransfer) return resolve([]);
        const items = dataTransfer.items ? Array.from(dataTransfer.items) : [];
        const pending = [];
        const files = [];

        const walkEntry = (entry) => new Promise((res) => {
            if (!entry) return res([]);
            if (entry.isFile) {
                entry.file((file) => res([file]), () => res([]));
            } else if (entry.isDirectory && entry.createReader) {
                const reader = entry.createReader();
                const all = [];
                const readChunk = () => {
                    reader.readEntries((entries) => {
                        if (!entries.length) {
                            Promise.all(all.map(walkEntry)).then((nested) => res(nested.flat()));
                            return;
                        }
                        all.push(...entries);
                        readChunk();
                    }, () => res([]));
                };
                readChunk();
            } else {
                res([]);
            }
        });

        if (items.length) {
            items.forEach((item) => {
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                    if (entry && (entry.isDirectory || entry.isFile)) {
                        pending.push(walkEntry(entry));
                    } else {
                        const f = item.getAsFile && item.getAsFile();
                        if (f) files.push(f);
                    }
                }
            });
            if (pending.length) {
                Promise.all(pending).then((nested) => {
                    resolve(files.concat(...nested));
                });
                return;
            }
        }
        resolve(Array.from(dataTransfer.files || []));
    });
}

function filterExplorerFiles(fileList) {
    const allowed = ['.csv', '.tsv', '.xlsx', '.xls'];
    return Array.from(fileList || []).filter((file) => {
        const name = file.name.toLowerCase();
        return allowed.some((ext) => name.endsWith(ext));
    });
}

function handleExplorerFiles(fileList) {
    const filtered = filterExplorerFiles(fileList);
    if (!filtered.length) return;
    explorerFiles = filtered;
    explorerTreeState = {};
    updateExplorerFileList(explorerFiles);
    renderExplorerTree(explorerFiles);
    const explorerFileList = document.getElementById('explorerFileList');
    if (explorerFiles[0] && explorerFileList) {
        explorerFileList.value = '0';
        readExplorerFile(explorerFiles[0]);
    }
}

function renderExplorerPreview() {
    const area = document.getElementById('explorer-preview-area');
    if (!area) return;
    const prevWrap = area.querySelector('.explorer-preview-wrap');
    const prevScrollTop = prevWrap ? prevWrap.scrollTop : 0;
    const prevScrollLeft = prevWrap ? prevWrap.scrollLeft : 0;
    if (!explorerData || explorerData.length === 0) {
        area.innerHTML = '<p class=\"explorer-note\">No preview available.</p>';
        return;
    }
    const maxRows = Math.min(200, explorerData.length);
    const maxCols = Math.max(...explorerData.slice(0, maxRows).map(r => r.length), 0);
    if (maxCols === 0) {
        area.innerHTML = '<p class="explorer-note">No preview available.</p>';
        return;
    }
    const hideDecimals = getExplorerHideDecimals();
    explorerColRecommendedWidths = computeExplorerColRecommendedWidths(maxCols, maxRows);
    explorerColHardMinWidths = computeExplorerColHardMinWidths(maxCols);
    const colWidths = normalizeExplorerColWidths(maxCols);
    const allWidth = Math.round(colWidths.reduce((a, b) => a + b, 0) / Math.max(1, colWidths.length));
    let html = `
        <div class="explorer-col-controls">
            <label>All columns width</label>
            <input type="range" id="explorerColWidthRange" min="${explorerColMinWidth}" max="${explorerColMaxWidth}" value="${allWidth}">
            <input type="number" id="explorerColWidthInput" min="${explorerColMinWidth}" max="${explorerColMaxWidth}" value="${allWidth}" style="width:80px;">
            <button type="button" id="explorerColWidthMinus">-20px</button>
            <button type="button" id="explorerColWidthPlus">+20px</button>
            <button type="button" id="explorerColWidthReset">Reset</button>
            <label style="display:flex; align-items:center; gap:6px;">
                <input type="checkbox" id="explorerHideDecimalsToggle"${hideDecimals ? ' checked' : ''}>
                Hide decimals
            </label>
        </div>
        <div class="explorer-preview-wrap"><table class="explorer-table fixed"><colgroup>`;
    for (let c = 0; c < maxCols; c++) {
        html += `<col style="width:${colWidths[c]}px;">`;
    }
    html += '</colgroup><thead><tr>';
    for (let c = 0; c < maxCols; c++) {
        const headerLabel = `Col ${c + 1}`;
        html += `<th data-col="${c}" title="${escapeHtml(headerLabel)}">${headerLabel}<span class="col-resizer" data-col="${c}"></span></th>`;
    }
    html += '</tr></thead><tbody>';
    for (let r = 0; r < maxRows; r++) {
        html += '<tr>';
        for (let c = 0; c < maxCols; c++) {
            const val = explorerData[r] && explorerData[r][c] !== undefined ? explorerData[r][c] : '';
            const displayVal = formatExplorerCellValue(val);
            const rawTitle = val === null || val === undefined ? '' : String(val);
            const cellClass = explorerSelection && r >= explorerSelection.r1 && r <= explorerSelection.r2 && c >= explorerSelection.c1 && c <= explorerSelection.c2
                ? 'explorer-selected'
                : '';
            html += `<td class=\"${cellClass}\" data-row=\"${r}\" data-col=\"${c}\" title="${escapeHtml(rawTitle)}">${escapeHtml(String(displayVal))}</td>`;
        }
        html += '</tr>';
    }
    html += '</tbody></table></div>';
    html += '<div class=\"explorer-note\">Click-drag to select cells, then release to stage.</div>';
    area.innerHTML = html;
    const wrap = area.querySelector('.explorer-preview-wrap');
    if (wrap) {
        wrap.scrollTop = prevScrollTop;
        wrap.scrollLeft = prevScrollLeft;
    }
    bindExplorerTable();
    bindExplorerColumnControls(maxCols);
    bindExplorerColumnResizers();
}

function clampExplorerColWidth(value, minOverride) {
    const minVal = Number.isFinite(minOverride) ? minOverride : explorerColMinWidth;
    const num = Math.round(Number(value) || explorerColDefaultWidth);
    return Math.min(explorerColMaxWidth, Math.max(minVal, num));
}

function escapeHtml(value) {
    return String(value)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function getExplorerHideDecimals() {
    if (explorerHideDecimals === null) {
        explorerHideDecimals = localStorage.getItem(explorerHideDecimalsKey) === 'true';
    }
    return explorerHideDecimals;
}

function computeExplorerColRecommendedWidths(colCount, rowCount) {
    if (!colCount) return [];
    const rowsToCheck = Math.min(explorerMinSampleRows, rowCount || 0);
    const recommended = [];
    for (let c = 0; c < colCount; c++) {
        let maxLen = `Col ${c + 1}`.length;
        for (let r = 0; r < rowsToCheck; r++) {
            const val = explorerData[r] && explorerData[r][c] !== undefined ? explorerData[r][c] : '';
            const len = String(val ?? '').length;
            if (len > maxLen) maxLen = len;
        }
        const estimate = explorerMinBase + maxLen * explorerMinCharPx;
        const floor = c === 0 ? explorerMinFloorFirst : explorerMinFloor;
        recommended[c] = clampExplorerColWidth(estimate, floor);
        if (recommended[c] > explorerMinCeil) recommended[c] = explorerMinCeil;
    }
    return recommended;
}

function computeExplorerColHardMinWidths(colCount) {
    return Array.from({ length: colCount }, (_, idx) =>
        idx === 0 ? explorerHardMinWidthFirst : explorerHardMinWidth
    );
}

function setExplorerHideDecimals(value) {
    explorerHideDecimals = !!value;
    try {
        localStorage.setItem(explorerHideDecimalsKey, explorerHideDecimals ? 'true' : 'false');
    } catch (err) {
        // Ignore storage errors.
    }
}

function formatExplorerCellValue(value) {
    if (!getExplorerHideDecimals()) return value ?? '';
    if (value === null || value === undefined) return '';
    if (typeof value === 'string' && value.trim() === '') return '';
    const num = typeof value === 'number' ? value : Number(String(value).trim());
    if (!Number.isFinite(num)) return value;
    return Math.trunc(num);
}

function loadExplorerColWidths() {
    try {
        const raw = localStorage.getItem(explorerColStorageKey);
        const parsed = raw ? JSON.parse(raw) : [];
        if (!Array.isArray(parsed)) return [];
        return parsed.map((w, idx) => clampExplorerColWidth(w, explorerColHardMinWidths[idx]));
    } catch (err) {
        return [];
    }
}

function saveExplorerColWidths() {
    try {
        localStorage.setItem(explorerColStorageKey, JSON.stringify(explorerColWidths));
    } catch (err) {
        // Ignore storage errors.
    }
}

function normalizeExplorerColWidths(colCount) {
    if (!colCount) {
        explorerColWidths = [];
        return explorerColWidths;
    }
    if (!explorerColWidths.length) {
        explorerColWidths = loadExplorerColWidths();
    }
    let sanitized = explorerColWidths.filter(n => Number.isFinite(n) && n > 0)
        .map((w, idx) => clampExplorerColWidth(w, explorerColHardMinWidths[idx]));
    if (!sanitized.length) {
        sanitized = Array.from({ length: colCount }, (_, idx) => {
            const recommended = explorerColRecommendedWidths[idx] || explorerColDefaultWidth;
            return clampExplorerColWidth(recommended, explorerColHardMinWidths[idx]);
        });
    }
    if (sanitized.length < colCount) {
        for (let i = sanitized.length; i < colCount; i++) {
            const recommended = explorerColRecommendedWidths[i] || explorerColDefaultWidth;
            sanitized.push(clampExplorerColWidth(recommended, explorerColHardMinWidths[i]));
        }
    }
    if (sanitized.length > colCount) {
        sanitized = sanitized.slice(0, colCount);
    }
    sanitized = sanitized.map((w, idx) => clampExplorerColWidth(w, explorerColHardMinWidths[idx]));
    explorerColWidths = sanitized;
    saveExplorerColWidths();
    return explorerColWidths;
}

function applyExplorerColWidths() {
    const table = document.querySelector('.explorer-table');
    if (!table) return;
    const cols = table.querySelectorAll('colgroup col');
    const headers = table.querySelectorAll('thead th');
    const rows = table.querySelectorAll('tbody tr');
    let totalWidth = 0;
    cols.forEach((col, idx) => {
        const minVal = explorerColHardMinWidths[idx] ?? explorerColMinWidth;
        const width = clampExplorerColWidth(explorerColWidths[idx] || explorerColDefaultWidth, minVal);
        explorerColWidths[idx] = width;
        col.style.width = `${width}px`;
        totalWidth += width;
    });
    headers.forEach((th, idx) => {
        const width = explorerColWidths[idx] || explorerColDefaultWidth;
        th.style.width = `${width}px`;
        th.style.maxWidth = `${width}px`;
    });
    rows.forEach((row) => {
        const cells = row.children;
        for (let i = 0; i < cells.length; i++) {
            const width = explorerColWidths[i] || explorerColDefaultWidth;
            cells[i].style.width = `${width}px`;
            cells[i].style.maxWidth = `${width}px`;
        }
    });
    if (totalWidth > 0) {
        table.style.width = `${totalWidth}px`;
    }
}

function updateExplorerColControlsValue() {
    const range = document.getElementById('explorerColWidthRange');
    const input = document.getElementById('explorerColWidthInput');
    if (!range || !input || !explorerColWidths.length) return;
    const avg = Math.round(explorerColWidths.reduce((a, b) => a + b, 0) / explorerColWidths.length);
    range.value = avg;
    input.value = avg;
}

function setAllExplorerColWidths(value) {
    if (!explorerData || explorerData.length === 0) return;
    const table = document.querySelector('.explorer-table');
    const cols = table ? table.querySelectorAll('colgroup col') : [];
    const colCount = cols.length;
    if (colCount === 0) return;
    const requested = Number(value) || 10;
    explorerColWidths = Array.from({ length: colCount }, (_, idx) => {
        const minVal = (explorerColHardMinWidths && explorerColHardMinWidths[idx]) ? explorerColHardMinWidths[idx] : 10;
        return Math.max(requested, minVal);
    });
    applyExplorerColWidths();
    saveExplorerColWidths();
    updateExplorerColControlsValue();
}

function bumpAllExplorerColWidths(delta) {
    explorerColWidths = explorerColWidths.map((w, idx) => {
        const minVal = explorerColHardMinWidths[idx];
        return clampExplorerColWidth(w + delta, minVal);
    });
    applyExplorerColWidths();
    saveExplorerColWidths();
    updateExplorerColControlsValue();
}

function bindExplorerColumnControls(maxCols) {
    if (!maxCols) return;
    const range = document.getElementById('explorerColWidthRange');
    const input = document.getElementById('explorerColWidthInput');
    const minus = document.getElementById('explorerColWidthMinus');
    const plus = document.getElementById('explorerColWidthPlus');
    const reset = document.getElementById('explorerColWidthReset');
    const hideDecimalsToggle = document.getElementById('explorerHideDecimalsToggle');
    if (range) {
        range.addEventListener('input', () => setAllExplorerColWidths(range.value));
    }
    if (input) {
        input.addEventListener('change', () => setAllExplorerColWidths(input.value));
        input.addEventListener('input', () => setAllExplorerColWidths(input.value));
    }
    if (minus) {
        minus.addEventListener('click', () => bumpAllExplorerColWidths(-20));
    }
    if (plus) {
        plus.addEventListener('click', () => bumpAllExplorerColWidths(20));
    }
    if (reset) {
        reset.addEventListener('click', () => {
            explorerColWidths = explorerColRecommendedWidths.slice();
            applyExplorerColWidths();
            saveExplorerColWidths();
            updateExplorerColControlsValue();
        });
    }
    if (hideDecimalsToggle) {
        hideDecimalsToggle.addEventListener('change', () => {
            setExplorerHideDecimals(hideDecimalsToggle.checked);
            renderExplorerPreview();
        });
    }
    updateExplorerColControlsValue();
}

let explorerColResizeState = null;

function handleExplorerColResizeMove(e) {
    if (!explorerColResizeState) return;
    const dx = e.clientX - explorerColResizeState.startX;
    const minVal = explorerColHardMinWidths[explorerColResizeState.colIndex];
    const next = clampExplorerColWidth(explorerColResizeState.startWidth + dx, minVal);
    explorerColWidths[explorerColResizeState.colIndex] = next;
    applyExplorerColWidths();
    saveExplorerColWidths();
}

function handleExplorerColResizeEnd() {
    explorerColResizeState = null;
    document.body.classList.remove('no-select');
    window.removeEventListener('pointermove', handleExplorerColResizeMove);
}

function bindExplorerColumnResizers() {
    const resizers = document.querySelectorAll('.col-resizer');
    resizers.forEach((resizer) => {
        resizer.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const colIndex = parseInt(resizer.dataset.col || '0', 10);
            const startWidth = explorerColWidths[colIndex] || explorerColDefaultWidth;
            explorerColResizeState = { colIndex, startX: e.clientX, startWidth };
            document.body.classList.add('no-select');
            window.addEventListener('pointermove', handleExplorerColResizeMove);
            window.addEventListener('pointerup', handleExplorerColResizeEnd, { once: true });
        });
        resizer.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const colIndex = parseInt(resizer.dataset.col || '0', 10);
            const recVal = explorerColRecommendedWidths[colIndex] || explorerColDefaultWidth;
            const hardMin = explorerColHardMinWidths[colIndex];
            explorerColWidths[colIndex] = clampExplorerColWidth(recVal, hardMin);
            applyExplorerColWidths();
            saveExplorerColWidths();
            updateExplorerColControlsValue();
        });
    });
}

function renderStagedGroups() {
    const area = document.getElementById('explorer-staged-area');
    if (!area) return;
    const groupIndices = Object.keys(stagedGroups).map(n => parseInt(n, 10)).filter(n => !isNaN(n));
    const currentGroups = document.querySelectorAll('.group-card').length;
    const maxGroup = Math.max(3, currentGroups, ...groupIndices, 3);
    let html = '';
    const mode = getExplorerMode();
    if (mode === 'time') {
        const timeItems = stagedTimeLabels.map((label, idx) => `
            <div class="time-label-item" data-index="${idx}">
                <span class="time-label-drag" draggable="true" data-index="${idx}">⠿</span>
                <input type="text" value="${label}" oninput="updateStagedTimeLabel(${idx}, this.value)">
                <button type="button" class="time-label-remove" onclick="removeStagedTimeLabel(${idx})">×</button>
            </div>
        `).join('');
        html += `
            <div class="staged-item" style="flex:1 1 100%;">
                <label style="font-size:0.75rem; color:var(--explorer-muted);">Time Labels</label>
                <div class="time-label-list" id="stagedTimeLabelList">${timeItems}</div>
                <button type="button" class="btn-mini" style="width:auto; margin-top:6px;" onclick="addStagedTimeLabel()">+ Time</button>
                <label style="font-size:0.75rem; color:var(--explorer-muted); margin-top:6px; display:block;">Bulk edit (space/tab/newline separated)</label>
                <textarea class="time-label-bulk" id="stagedTimeLabelsBulk">${stagedTimeLabels.join(' ')}</textarea>
                <button type="button" class="btn-mini" style="width:auto; margin-top:6px;" onclick="applyStagedTimeLabelsBulk()">Apply</button>
            </div>
        `;
    }
    for (let i = 1; i <= maxGroup; i++) {
        const nameVal = stagedGroupNames[i] || `Group ${i}`;
        if (mode === 'time') {
            const cols = parseData(stagedGroups[i] || '', stagedTimeLabels.length || 1);
            const timeCols = (stagedTimeLabels.length ? stagedTimeLabels : Array.from({ length: cols.length || 1 }, (_, idx) => `Time${idx + 1}`))
                .map((label, idx) => {
                    const values = (cols[idx] || []).join('\n');
                    return `
                        <div class="group-time-col" draggable="true" data-index="${idx}" data-staged-group="${i}">
                            <label>${label || `Time${idx + 1}`}</label>
                            <textarea oninput="updateStagedGroupTimeColumn(${i}, ${idx}, this.value)">${values}</textarea>
                        </div>
                    `;
                }).join('');
            html += `
                <div class="staged-item" style="flex:1 1 100%;">
                    <label style="font-size:0.75rem; color:var(--explorer-muted);">Group ${i}</label>
                    <input type="text" data-staged-name="${i}" value="${nameVal}" style="width:100%; font-size:0.85rem; padding:4px 6px; border-radius:4px; border:1px solid var(--explorer-border); background:var(--explorer-card); color:var(--explorer-text);" oninput="updateStagedName(${i}, this.value)">
                    <div class="group-time-grid" data-staged-group="${i}">${timeCols}</div>
                </div>
            `;
        } else {
            const val = stagedGroups[i] || '';
            html += `
                <div class="staged-item">
                    <label style="font-size:0.75rem; color:var(--explorer-muted);">Group ${i}</label>
                    <input type="text" data-staged-name="${i}" value="${nameVal}" style="width:100%; font-size:0.85rem; padding:4px 6px; border-radius:4px; border:1px solid var(--explorer-border); background:var(--explorer-card); color:var(--explorer-text);" oninput="updateStagedName(${i}, this.value)">
                    <textarea data-staged="${i}" oninput="updateStagedFromTextarea(${i}, this.value)">${val}</textarea>
                </div>
            `;
        }
    }
    area.innerHTML = html;
    if (mode === 'time') {
        const stagedList = document.getElementById('stagedTimeLabelList');
        bindStagedTimeLabelDrag(stagedList);
        area.querySelectorAll('.group-time-grid').forEach((grid) => bindGroupTimeDrag(grid));
        area.querySelectorAll('.time-label-item input').forEach((input) => {
            input.draggable = false;
            input.addEventListener('mousedown', (e) => e.stopPropagation());
            input.addEventListener('dragstart', (e) => e.preventDefault());
        });
    }
    renderExplorerTimeSelect();
}

function updateStagedFromTextarea(idx, value) {
    stagedGroups[idx] = value;
}
function updateStagedName(idx, value) {
    stagedGroupNames[idx] = value;
    renderExplorerMenuGroups();
}
function updateStagedTimeLabels(value) {
    stagedTimeLabels = parseTimeLabelText(value);
    renderExplorerTimeSelect();
}

function updateStagedTimeLabel(idx, value) {
    stagedTimeLabels[idx] = String(value || '').trim();
    stagedTimeLabels = stagedTimeLabels.filter(l => l !== '');
    renderStagedGroups();
    renderExplorerTimeSelect();
}

function updateStagedGroupTimeColumn(groupIdx, timeIdx, value) {
    const values = value.split(/\r?\n/).map(v => v.trim()).filter(v => v !== '');
    const count = Math.max(stagedTimeLabels.length, timeIdx + 1);
    const current = stagedGroups[groupIdx] || '';
    stagedGroups[groupIdx] = setTimeColumnsInGroupText(current, timeIdx, values, count);
}

function saveExplorerStash() {
    collectStagedGroupsFromUI();
    const payload = {
        groups: stagedGroups,
        names: stagedGroupNames,
        timeLabels: stagedTimeLabels
    };
    localStorage.setItem('explorerStash', JSON.stringify(payload));
    showToast('Staged data saved.');
}

function loadExplorerStash() {
    const raw = localStorage.getItem('explorerStash');
    if (!raw) {
        showToast('No saved staged data.');
        return;
    }
    try {
        const payload = JSON.parse(raw);
        stagedGroups = payload.groups || {};
        stagedGroupNames = payload.names || {};
        stagedTimeLabels = payload.timeLabels || [];
        renderStagedGroups();
        showToast('Staged data loaded.');
    } catch (err) {
        showToast('Failed to load staged data.');
    }
}

function addStagedTimeLabel() {
    stagedTimeLabels.push(`Time${stagedTimeLabels.length + 1}`);
    renderStagedGroups();
    renderExplorerTimeSelect();
}

function removeStagedTimeLabel(idx) {
    stagedTimeLabels.splice(idx, 1);
    renderStagedGroups();
    renderExplorerTimeSelect();
}

function applyStagedTimeLabelsBulk() {
    const bulk = document.getElementById('stagedTimeLabelsBulk');
    if (!bulk) return;
    const labels = parseTimeLabelText(bulk.value);
    if (!labels.length) return;
    stagedTimeLabels = labels;
    renderStagedGroups();
    renderExplorerTimeSelect();
}

function collectStagedGroupsFromUI() {
    const area = document.getElementById('explorer-staged-area');
    if (!area) return;
    const mode = getExplorerMode();
    stagedGroups = {};
    stagedGroupNames = {};
    if (mode === 'time') {
        const grids = area.querySelectorAll('.group-time-grid[data-staged-group]');
        grids.forEach((grid) => {
            const groupIdx = parseInt(grid.dataset.stagedGroup, 10);
            if (isNaN(groupIdx)) return;
            const cols = Array.from(grid.querySelectorAll('.group-time-col')).map((col) => {
                const ta = col.querySelector('textarea');
                return ta ? ta.value.split(/\r?\n/).map(v => v.trim()).filter(v => v !== '') : [];
            });
            stagedGroups[groupIdx] = buildMatrixFromColumns(cols);
        });
    } else {
        const inputs = area.querySelectorAll('textarea[data-staged]');
        inputs.forEach((ta) => {
            const idx = parseInt(ta.dataset.staged, 10);
            if (!isNaN(idx)) {
                stagedGroups[idx] = ta.value;
            }
        });
    }
    const nameInputs = area.querySelectorAll('input[data-staged-name]');
    nameInputs.forEach((inp) => {
        const idx = parseInt(inp.dataset.stagedName, 10);
        if (!isNaN(idx)) {
            stagedGroupNames[idx] = inp.value;
        }
    });
    const timeInputs = area.querySelectorAll('.time-label-item input');
    if (timeInputs.length) {
        stagedTimeLabels = Array.from(timeInputs).map(inp => inp.value.trim()).filter(Boolean);
    }
}

function buildExplorerTree(files, basePrefix = '') {
    const root = { children: {}, files: [] };
    files.forEach((file, idx) => {
        const rawPathFull = (file.webkitRelativePath || file.name || '').replace(/\\\\/g, '/').replace(/\\+/g, '/');
        const rawPath = basePrefix && rawPathFull.startsWith(basePrefix)
            ? rawPathFull.slice(basePrefix.length).replace(/^\//, '').replace(/^\//, '')
            : rawPathFull;
        const parts = rawPath.split('/').filter(Boolean);
        const fileName = parts.pop() || file.name;
        let node = root;
        let pathAcc = '';
        parts.forEach((part) => {
            pathAcc = pathAcc ? `${pathAcc}/${part}` : part;
            if (!node.children[part]) {
                node.children[part] = { children: {}, files: [], path: pathAcc };
            }
            node = node.children[part];
        });
        node.files.push({ name: fileName, idx, fullPath: rawPath || fileName });
    });
    return root;
}

function renderExplorerTree(files) {
    const treeEl = document.getElementById('explorerFileTree');
    if (!treeEl) return;
    if (!files || !files.length) {
        treeEl.innerHTML = '<div class="tree-note">フォルダをドロチEEするとチEー表示されます、E/div>';
        return;
    }
    const relPaths = files.map((file) => (file.webkitRelativePath || file.name || '').replace(/\\\\/g, '/').replace(/\\+/g, '/'));
    const commonRoot = (() => {
        if (!relPaths.length) return '';
        const splitPaths = relPaths.map(p => p.split('/').filter(Boolean));
        const minLen = Math.min(...splitPaths.map(p => p.length));
        const parts = [];
        for (let i = 0; i < minLen; i++) {
            const seg = splitPaths[0][i];
            if (splitPaths.every(p => p[i] === seg)) {
                parts.push(seg);
            } else {
                break;
            }
        }
        return parts.length ? parts.join('/') : '';
    })();
    const root = buildExplorerTree(files, commonRoot ? `${commonRoot}` : '');
    const lines = [];

    function renderNode(node, name, depth, parentPath) {
        const key = parentPath ? `${parentPath}/${name}` : name || '';
        const isRoot = depth === 0;
        const indent = depth > 0 ? 'padding-left:' + (depth * 12) + 'px;' : '';
        if (!isRoot) {
            const hasChildren = Object.keys(node.children).length > 0 || node.files.length > 0;
            const open = explorerTreeState[key] === true;
            const toggle = hasChildren ? (open ? '▼' : '▶') : '•';
            lines.push(`
                <div class="tree-node" style="${indent}">
                    <div class="tree-dir" data-path="${key}" data-open="${open}">
                        <span class="tree-toggle">${toggle}</span>
                        <span class="tree-name">${name}</span>
                    </div>
                </div>
            `);
            if (!open) return;
        }
        const childKeys = Object.keys(node.children).sort();
        childKeys.forEach((child) => renderNode(node.children[child], child, depth + 1, key));
        node.files
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach((f) => {
                const fIndent = 'padding-left:' + ((depth + 1) * 12) + 'px;';
                lines.push(`
                    <div class="tree-node" style="${fIndent}">
                        <div class="tree-file" data-file-idx="${f.idx}">
                            <span class="tree-toggle">•</span>
                            <span class="tree-name">${f.name}</span>
                        </div>
                    </div>
                `);
            });
    }

    renderNode(root, '', 0, '');
    treeEl.innerHTML = lines.join('');

    treeEl.querySelectorAll('.tree-dir').forEach((dir) => {
        dir.addEventListener('click', () => {
            const path = dir.dataset.path || '';
            const open = dir.dataset.open === 'true';
            explorerTreeState[path] = !open;
            treeEl.querySelectorAll('.tree-dir.selected, .tree-file.selected').forEach((el) => el.classList.remove('selected'));
            dir.classList.add('selected');
            renderExplorerTree(files);
        });
    });
    treeEl.querySelectorAll('.tree-file').forEach((fileEl) => {
        fileEl.addEventListener('click', () => {
            const idx = parseInt(fileEl.dataset.fileIdx, 10);
            if (!isNaN(idx) && files[idx]) {
                treeEl.querySelectorAll('.tree-dir.selected, .tree-file.selected').forEach((el) => el.classList.remove('selected'));
                fileEl.classList.add('selected');
                const explorerFileList = document.getElementById('explorerFileList');
                if (explorerFileList) explorerFileList.value = String(idx);
                readExplorerFile(files[idx]);
            }
        });
    });
}

function bindExplorerTable() {
    const table = document.querySelector('.explorer-table');
    if (!table) return;
    table.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // only left-click initiates selection
        const cell = e.target.closest('td');
        if (!cell) return;
        explorerSelecting = true;
        const r = parseInt(cell.dataset.row, 10);
        const c = parseInt(cell.dataset.col, 10);
        explorerSelection = { r1: r, r2: r, c1: c, c2: c };
        explorerLastPointer = { x: e.clientX, y: e.clientY };
        hideExplorerMenu();
        updateExplorerSelectionHighlight(table);
    });
    table.addEventListener('mouseover', (e) => {
        if (!explorerSelecting) return;
        const cell = e.target.closest('td');
        if (!cell) return;
        const r = parseInt(cell.dataset.row, 10);
        const c = parseInt(cell.dataset.col, 10);
        explorerSelection.r2 = r;
        explorerSelection.c2 = c;
        normalizeExplorerSelection();
        explorerLastPointer = { x: e.clientX, y: e.clientY };
        updateExplorerSelectionHighlight(table);
    });
    table.addEventListener('mouseleave', () => {
        if (explorerSelecting) {
            updateExplorerSelectionHighlight(table);
        }
    });
    table.addEventListener('mousemove', (e) => {
        explorerLastPointer = { x: e.clientX, y: e.clientY };
    });
    table.addEventListener('contextmenu', (e) => {
        const cell = e.target.closest('td');
        if (!cell) return;
        e.preventDefault();
        const r = parseInt(cell.dataset.row, 10);
        const c = parseInt(cell.dataset.col, 10);
        const alreadySelected = explorerSelection
            && r >= explorerSelection.r1 && r <= explorerSelection.r2
            && c >= explorerSelection.c1 && c <= explorerSelection.c2;
        if (!alreadySelected) {
            explorerSelection = { r1: r, r2: r, c1: c, c2: c };
            updateExplorerSelectionHighlight(table);
        }
        showExplorerMenu(e.clientX, e.clientY);
    });
    table.addEventListener('mouseup', (e) => {
        explorerLastPointer = { x: e.clientX, y: e.clientY };
        handleExplorerMouseUp(e);
    });
    if (!explorerDocMouseUpHandlerAdded) {
        document.addEventListener('mouseup', handleExplorerMouseUp);
        explorerDocMouseUpHandlerAdded = true;
    }
}

function normalizeExplorerSelection() {
    if (!explorerSelection) return;
    const rMin = Math.min(explorerSelection.r1, explorerSelection.r2);
    const rMax = Math.max(explorerSelection.r1, explorerSelection.r2);
    const cMin = Math.min(explorerSelection.c1, explorerSelection.c2);
    const cMax = Math.max(explorerSelection.c1, explorerSelection.c2);
    explorerSelection = { r1: rMin, r2: rMax, c1: cMin, c2: cMax };
}

function updateExplorerSelectionHighlight(table) {
    if (!table) table = document.querySelector('.explorer-table');
    if (!table) return;
    const cells = table.querySelectorAll('td');
    cells.forEach((cell) => {
        const r = parseInt(cell.dataset.row, 10);
        const c = parseInt(cell.dataset.col, 10);
        const selected = explorerSelection && r >= explorerSelection.r1 && r <= explorerSelection.r2 && c >= explorerSelection.c1 && c <= explorerSelection.c2;
        cell.classList.toggle('explorer-selected', !!selected);
    });
}

function handleExplorerMouseUp(e) {
    if (!explorerSelecting) return;
    explorerSelecting = false;
    normalizeExplorerSelection();
    updateExplorerSelectionHighlight();
    explorerLastPointer = {
        x: (e && e.clientX) || explorerLastPointer.x,
        y: (e && e.clientY) || explorerLastPointer.y
    };
    const x = explorerLastPointer.x;
    const y = explorerLastPointer.y;
    showExplorerMenu(x, y);
}

function onBarPointerDown(e) {
    const rect = e.target.closest('rect.bar-draggable');
    if (!rect) return;
    const idx = parseInt(rect.dataset.groupIndex, 10);
    if (isNaN(idx)) return;
    e.preventDefault();
    pushUndoState();
    draggingBarIndex = idx;
    draggingStartOffset = groupOffsetX[idx] || 0;
    draggingBarStartX = e.clientX;
    rect.classList.add('dragging');
    window.addEventListener('pointermove', onBarPointerMove);
    window.addEventListener('pointerup', onBarPointerUp, { once: true });
}

function onGroupLabelPointerDown(e) {
    const label = e.target.closest('text.group-label');
    if (!label) return false;
    const idx = parseInt(label.dataset.groupIndex, 10);
    if (isNaN(idx)) return true;
    e.preventDefault();
    draggingGroupLabelIndex = idx;
    draggingGroupLabelStartY = e.clientY;
    draggingGroupLabelStartOffset = groupLabelOffsetY[idx] || 0;
    window.addEventListener('pointermove', onGroupLabelPointerMove);
    window.addEventListener('pointerup', onGroupLabelPointerUp, { once: true });
    return true;
}

function onGroupLabelPointerMove(e) {
    if (draggingGroupLabelIndex === null) return;
    const svgContainer = document.getElementById('svg-container');
    const svg = svgContainer ? svgContainer.querySelector('svg') : null;
    if (!svg || !plotMetrics) return;
    const rect = svg.getBoundingClientRect();
    if (!rect.height) return;
    const dyPx = e.clientY - draggingGroupLabelStartY;
    const scaleY = plotMetrics.height / rect.height;
    groupLabelOffsetY[draggingGroupLabelIndex] = draggingGroupLabelStartOffset + (dyPx * scaleY);
    updatePlot();
}

function onGroupLabelPointerUp() {
    draggingGroupLabelIndex = null;
    window.removeEventListener('pointermove', onGroupLabelPointerMove);
    updatePlot();
}

function onAxisLabelPointerDown(e) {
    const label = e.target.closest('text.axis-label');
    if (!label) return false;
    const type = label.dataset.label;
    if (!type) return false;
    e.preventDefault();
    draggingAxisLabel = type;
    draggingAxisLabelStartX = e.clientX;
    draggingAxisLabelStartY = e.clientY;
    if (type === 'title') {
        draggingAxisLabelStartOffsetX = titleOffsetX;
        draggingAxisLabelStartOffsetY = titleOffsetY;
    } else if (type === 'x') {
        draggingAxisLabelStartOffsetX = xAxisLabelOffsetX;
        draggingAxisLabelStartOffsetY = xAxisLabelOffsetY;
    } else if (type === 'y') {
        draggingAxisLabelStartOffsetX = yAxisLabelOffsetX;
        draggingAxisLabelStartOffsetY = yAxisLabelOffsetY;
    }
    window.addEventListener('pointermove', onAxisLabelPointerMove);
    window.addEventListener('pointerup', onAxisLabelPointerUp, { once: true });
    return true;
}

function onAxisLabelPointerMove(e) {
    if (!draggingAxisLabel) return;
    const scale = getDisplayScale();
    const dx = (e.clientX - draggingAxisLabelStartX) / scale;
    const dy = (e.clientY - draggingAxisLabelStartY) / scale;
    if (draggingAxisLabel === 'title') {
        titleOffsetX = draggingAxisLabelStartOffsetX + dx;
        titleOffsetY = draggingAxisLabelStartOffsetY + dy;
    } else if (draggingAxisLabel === 'x') {
        xAxisLabelOffsetX = draggingAxisLabelStartOffsetX + dx;
        xAxisLabelOffsetY = draggingAxisLabelStartOffsetY + dy;
    } else if (draggingAxisLabel === 'y') {
        yAxisLabelOffsetX = draggingAxisLabelStartOffsetX + dx;
        yAxisLabelOffsetY = draggingAxisLabelStartOffsetY + dy;
    }
    updatePlot();
}

function onAxisLabelPointerUp() {
    draggingAxisLabel = null;
    window.removeEventListener('pointermove', onAxisLabelPointerMove);
    updatePlot();
}

function onBarPointerMove(e) {
    if (draggingBarIndex === null) return;
    const step = e.shiftKey ? 10 : (e.altKey ? 1 : 2);
    const scale = getDisplayScale();
    const dx = (e.clientX - draggingBarStartX) / scale;
    const snapped = Math.round(dx / step) * step;
    groupOffsetX[draggingBarIndex] = draggingStartOffset + snapped;
    updatePlot();
}

function onBarPointerUp() {
    draggingBarIndex = null;
    window.removeEventListener('pointermove', onBarPointerMove);
    updatePlot();
}

function getDisplayScale() {
    const svg = document.querySelector('#svg-container svg');
    if (!svg || !plotMetrics) return 1;
    const rect = svg.getBoundingClientRect();
    if (!rect.width || !plotMetrics.width) return 1;
    return rect.width / plotMetrics.width;
}

function getExplorerMode() {
    const explorerMode = document.getElementById('explorerMode');
    const plotMode = document.getElementById('plotMode');
    return (explorerMode && explorerMode.value) || (plotMode && plotMode.value) || 'comparison';
}

function getAvailableTimeLabels() {
    if (stagedTimeLabels && stagedTimeLabels.length) return stagedTimeLabels;
    return getTimeLabels();
}

function renderExplorerTimeSelect() {
    const select = document.getElementById('explorerTimeIndexMenu');
    if (!select) return;
    const labels = getAvailableTimeLabels();
    select.innerHTML = '';
    if (!labels.length) {
        const opt = document.createElement('option');
        opt.value = '0';
        opt.textContent = 'Time1';
        select.appendChild(opt);
        return;
    }
    labels.forEach((label, idx) => {
        const opt = document.createElement('option');
        opt.value = String(idx);
        opt.textContent = label || `Time${idx + 1}`;
        select.appendChild(opt);
    });
}

function renderExplorerMenuGroups() {
    const container = document.getElementById('explorerGroupButtons');
    if (!container) return;
    const groupIndices = Object.keys(stagedGroups).map(n => parseInt(n, 10)).filter(n => !isNaN(n));
    const currentGroups = document.querySelectorAll('.group-card').length;
    const maxGroup = Math.max(3, currentGroups, ...groupIndices, 3);
    container.innerHTML = '';
    for (let i = 1; i <= maxGroup; i++) {
        const btn = document.createElement('button');
        btn.type = 'button';
        const stagedInput = document.querySelector(`#explorer-staged-area input[data-staged-name="${i}"]`);
        const stagedInputVal = stagedInput ? stagedInput.value.trim() : '';
        const stagedName = (stagedGroupNames[i] || '').trim();
        const mainName = (document.querySelector(`#group_${i} .group-name-input`)?.value || '').trim();
        const label = stagedInputVal || stagedName || mainName || `Group ${i}`;
        btn.textContent = `Stage to ${label}`;
        btn.addEventListener('click', () => sendExplorerToGroup(i));
        container.appendChild(btn);
    }
}

function addExplorerGroup() {
    const groupIndices = Object.keys(stagedGroups).map(n => parseInt(n, 10)).filter(n => !isNaN(n));
    const currentGroups = document.querySelectorAll('.group-card').length;
    const next = Math.max(3, currentGroups, ...groupIndices, 3) + 1;
    if (!stagedGroups[next]) stagedGroups[next] = '';
    if (!stagedGroupNames[next]) stagedGroupNames[next] = `Group ${next}`;
    const idxInput = document.getElementById('explorerGroupIndexMenu');
    if (idxInput) idxInput.value = String(next);
    renderStagedGroups();
    renderExplorerMenuGroups();
}

function getExplorerSelectionValues() {
    if (!explorerData || !explorerSelection) return [];
    const values = [];
    for (let r = explorerSelection.r1; r <= explorerSelection.r2; r++) {
        for (let c = explorerSelection.c1; c <= explorerSelection.c2; c++) {
            const val = explorerData[r]?.[c];
            if (val === undefined || val === null) continue;
            const text = String(val).trim();
            if (text !== '') values.push(text);
        }
    }
    return values;
}

function getExplorerSelectionMatrix() {
    if (!explorerData || !explorerSelection) return [];
    const rows = [];
    for (let r = explorerSelection.r1; r <= explorerSelection.r2; r++) {
        const row = [];
        for (let c = explorerSelection.c1; c <= explorerSelection.c2; c++) {
            const val = explorerData[r]?.[c];
            row.push(val === undefined || val === null ? '' : String(val).trim());
        }
        rows.push(row);
    }
    return rows;
}

function stageExplorerTimeLabels(replace = true) {
    const values = getExplorerSelectionValues();
    if (!values.length) return;
    if (replace) {
        stagedTimeLabels = values;
    } else {
        values.forEach((val) => {
            if (!stagedTimeLabels.includes(val)) stagedTimeLabels.push(val);
        });
    }
    renderStagedGroups();
    renderExplorerTimeSelect();
    hideExplorerMenu();
}

function mergeTimeGroupData(existingText, matrix) {
    const leftRows = (existingText || '').split('\n').map(line => {
        const trimmed = line.trim();
        if (!trimmed) return [];
        return trimmed.includes('\t') ? trimmed.split('\t') : trimmed.split(/\s+/);
    });
    const rightRows = matrix.map((row) => row.map((cell) => {
        const num = parseFloat(cell);
        if (cell === '' || cell === null || cell === undefined) return '';
        return Number.isFinite(num) ? num : '';
    }));
    const rowCount = Math.max(leftRows.length, rightRows.length);
    const merged = [];
    for (let i = 0; i < rowCount; i++) {
        const left = leftRows[i] || [];
        const right = rightRows[i] || [];
        merged.push([...left, ...right].join('\t').trimEnd());
    }
    return merged.filter(line => line.trim() !== '').join('\n');
}

function setTimeColumnsInGroupText(existingText, startIndex, values, timeCount) {
    const rows = (existingText || '').trim() === '' ? [] : (existingText || '').split('\n').map(line => line.split('\t'));
    const rowCount = Math.max(rows.length, values.length);
    for (let r = 0; r < rowCount; r++) {
        if (!rows[r]) rows[r] = Array(timeCount).fill('');
        while (rows[r].length < timeCount) rows[r].push('');
        const val = values[r];
        if (val !== undefined && val !== null && val !== '') {
            rows[r][startIndex] = val;
        }
    }
    return rows.map(row => row.join('\t').trimEnd()).filter(line => line.trim() !== '').join('\n');
}

function showExplorerMenu(x, y) {
    const menu = document.getElementById('explorerMenu');
    if (!menu) return;
    renderExplorerMenuGroups();
    const timeActions = document.getElementById('explorerTimeActions');
    if (timeActions) {
        timeActions.style.display = getExplorerMode() === 'time' ? 'flex' : 'none';
    }
    const timeTarget = document.getElementById('explorerTimeTargetRow');
    if (timeTarget) {
        timeTarget.style.display = getExplorerMode() === 'time' ? 'flex' : 'none';
    }
    if (getExplorerMode() === 'time') {
        renderExplorerTimeSelect();
    }
    menu.style.left = `${x + 10}px`;
    menu.style.top = `${y + 10}px`;
    menu.style.display = 'block';
}

function hideExplorerMenu() {
    const menu = document.getElementById('explorerMenu');
    if (menu) menu.style.display = 'none';
}

function sendExplorerToGroup(groupNumber) {
    if (!explorerData || !explorerSelection) return;
    const idxInput = document.getElementById('explorerGroupIndexMenu');
    const targetGroup = groupNumber || (idxInput ? parseInt(idxInput.value, 10) : 1);
    if (!targetGroup || targetGroup < 1) return;
    if (!stagedGroupNames[targetGroup]) {
        stagedGroupNames[targetGroup] = `Group ${targetGroup}`;
    }
    const mode = getExplorerMode();
    if (mode === 'time') {
        const matrixRaw = getExplorerSelectionMatrix();
        if (!matrixRaw.length) return;
        const matrix = matrixRaw.map(row => row.map((cell) => {
            const num = parseFloat(cell);
            if (cell === '' || cell === null || cell === undefined) return '';
            return Number.isFinite(num) ? num : '';
        }));
        const timeLabels = getAvailableTimeLabels();
        const timeSelect = document.getElementById('explorerTimeIndexMenu');
        let startIdx = timeSelect ? parseInt(timeSelect.value, 10) : 0;
        if (isNaN(startIdx) || startIdx < 0) startIdx = 0;
        const colCount = matrix[0] ? matrix[0].length : 1;
        const requiredCount = Math.max(timeLabels.length, startIdx + colCount);
        if (stagedTimeLabels.length < requiredCount) {
            for (let i = stagedTimeLabels.length; i < requiredCount; i++) {
                stagedTimeLabels.push(`Time${i + 1}`);
            }
        }
        let currentText = stagedGroups[targetGroup] || '';
        for (let c = 0; c < colCount; c++) {
            const colValues = matrix.map(row => row[c]).filter(v => v !== '' && v !== null && v !== undefined);
            currentText = setTimeColumnsInGroupText(currentText, startIdx + c, colValues, requiredCount);
        }
        stagedGroups[targetGroup] = currentText;
    } else {
        const rows = [];
        for (let r = explorerSelection.r1; r <= explorerSelection.r2; r++) {
            for (let c = explorerSelection.c1; c <= explorerSelection.c2; c++) {
                if (!explorerData[r]) continue;
                const val = explorerData[r][c];
                if (val !== undefined && val !== null && val !== '' && !isNaN(parseFloat(val))) {
                    rows.push(parseFloat(val));
                }
            }
        }
        stagedGroups[targetGroup] = rows.join('\n');
    }
    renderStagedGroups();
    renderExplorerTimeSelect();
    renderExplorerTree(explorerFiles);
    hideExplorerMenu();
}

function sendExplorerToTitle() {
    if (!explorerData || !explorerSelection) return;
    if (explorerSelection.r1 !== explorerSelection.r2 || explorerSelection.c1 !== explorerSelection.c2) {
        showToast('Select a single cell for title.');
        return;
    }
    const value = explorerData[explorerSelection.r1]?.[explorerSelection.c1];
    if (value === undefined || value === null) return;
    const text = String(value).trim();
    if (!text) return;
    const mainEl = document.getElementById('chartTitleInput');
    if (mainEl) mainEl.value = text;
    updateExplorerTitleDisplay();
    updatePlot();
    hideExplorerMenu();
}

function applyStagedGroups() {
    // 1. Collect staged UI data
    collectStagedGroupsFromUI();

    // 2. Determine staged group indices
    const indices = Object.keys(stagedGroups)
        .map(n => parseInt(n, 10))
        .filter(n => !isNaN(n) && stagedGroups[n] && stagedGroups[n].trim() !== '');

    const mode = getExplorerMode();
    if (mode === 'survival') {
        showToast('Survival mode staging is not supported yet.');
        return;
    }
    if (mode === 'longitudinal') {
        showToast('Longitudinal mode uses raw CSV or posterior JSON.');
        return;
    }

    if (indices.length === 0 && !(mode === 'time' && stagedTimeLabels.length)) {
        showToast("No data staged to send.");
        return;
    }

    const plotMode = document.getElementById('plotMode');
    if (plotMode) {
        plotMode.value = mode;
        setPlotMode();
    }

    if (mode === 'time' && stagedTimeLabels.length) {
        setTimeLabels(stagedTimeLabels);
    }

    // B. Ensure group IDs are contiguous
    renumberGroups();

    // 3. Apply staged data
    indices.sort((a, b) => a - b).forEach((groupNum) => {
        // Create missing groups up to target
        while (groupCount < groupNum) {
            const isTarget = (groupCount + 1) === groupNum;
            const initialData = isTarget ? (stagedGroups[groupNum] || "") : "";
            const initialName = isTarget ? (stagedGroupNames[groupNum] || `Group ${groupNum}`) : "";
            addNewGroup(initialName, "", initialData);
        }

        // Update group data
        const target = document.getElementById(`group_${groupNum}`);
        
        if (target) {
            const textarea = target.querySelector('.group-data-input');
            if (textarea) {
                textarea.value = stagedGroups[groupNum] || '';
            }
            const nameInput = target.querySelector('.group-name-input');
            if (nameInput) {
                nameInput.value = stagedGroupNames[groupNum] || nameInput.value;
            }

            handlePaste(target.id);
            if (mode === 'time') {
                renderGroupTimeGrid(target);
            }
        }
    });

    // 4. Auto-reset Y max
    const yMaxInputEl = document.getElementById('yMaxInput');
    if (yMaxInputEl) {
        yMaxInputEl.dataset.auto = 'true';
        yMaxInputEl.value = '0';
    }
    updatePlot();

    const explorerPanel = document.getElementById('explorer-panel');
    if (explorerPanel) {
        explorerPanel.classList.remove('pinned');
    }

    if (indices.length > 0) {
        showToast(`Updated ${indices.length} group(s)!`);
    } else {
        showToast('Updated time labels.');
    }
}

function clearStagedGroups() {
    stagedGroups = {};
    stagedGroupNames = {};
    stagedTimeLabels = [];
    renderStagedGroups();
}

function clearGroupDataInputs(skipUpdate = false) {
    const cards = document.querySelectorAll('.group-card');
    cards.forEach((card) => {
        const textarea = card.querySelector('.group-data-input');
        if (textarea) textarea.value = '';
        card.querySelectorAll('.group-time-col textarea').forEach((ta) => {
            ta.value = '';
        });
        const preview = card.querySelector('.paste-preview');
        if (preview) preview.innerHTML = '';
    });
    if (!skipUpdate) updatePlot();
}

document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('plotMode')) {
        setPlotMode();
    }
    updateExportPathLabel();
    updateExplorerTitleDisplay();
    const timeInput = document.getElementById('timePointsInput');
    if (timeInput) {
        const initial = timeInput.value.trim().split(/[\t\s]+/).filter(Boolean);
        if (initial.length) {
            timeLabelState = initial;
        } else {
            timeLabelState = ['Day1', 'Day3', 'Day7'];
        }
        syncTimePointsInput();
        renderTimeLabelInputs();
        renderExplorerTimeSelect();
        updateTimeLabelsBulk();
    }
    const addTimeLabelBtn = document.getElementById('addTimeLabelBtn');
    if (addTimeLabelBtn) {
        addTimeLabelBtn.addEventListener('click', () => addTimeLabel());
    }
    const themeSelect = document.getElementById('themeSelect');
    const systemMedia = window.matchMedia('(prefers-color-scheme: dark)');
    const applyTheme = (mode) => {
        const theme = mode === 'system' ? (systemMedia.matches ? 'dark' : 'light') : mode;
        document.documentElement.setAttribute('data-theme', theme);
        updatePlot();
    };
    const storedTheme = localStorage.getItem('plotTheme') || 'system';
    if (themeSelect) themeSelect.value = storedTheme;
    applyTheme(storedTheme);
    if (themeSelect) {
        themeSelect.addEventListener('change', () => {
            localStorage.setItem('plotTheme', themeSelect.value);
            applyTheme(themeSelect.value);
        });
    }
    systemMedia.addEventListener('change', () => {
        const current = localStorage.getItem('plotTheme') || 'system';
        if (current === 'system') applyTheme('system');
    });
    const longitudinalRawInput = document.getElementById('longitudinalRawInput');
    const longitudinalPosteriorInput = document.getElementById('longitudinalPosteriorInput');
    const longitudinalCiSlider = document.getElementById('longitudinalCiSlider');
    const longitudinalIdCol = document.getElementById('longitudinalIdCol');
    const longitudinalGroupCol = document.getElementById('longitudinalGroupCol');
    const longitudinalTimeCol = document.getElementById('longitudinalTimeCol');
    const longitudinalYCol = document.getElementById('longitudinalYCol');
    const longitudinalLegendSize = document.getElementById('longitudinalLegendSize');
    const longitudinalAxisWidth = document.getElementById('longitudinalAxisWidth');
    const longitudinalLineWidth = document.getElementById('longitudinalLineWidth');
    const longitudinalCiLineWidth = document.getElementById('longitudinalCiLineWidth');
    const longitudinalTimeYMin = document.getElementById('longitudinalTimeYMin');
    const longitudinalTimeYMax = document.getElementById('longitudinalTimeYMax');
    const longitudinalTimeYMinSlider = document.getElementById('longitudinalTimeYMinSlider');
    const longitudinalTimeYMaxSlider = document.getElementById('longitudinalTimeYMaxSlider');
    const longitudinalTimeYAuto = document.getElementById('longitudinalTimeYAuto');
    const longitudinalDiffXMin = document.getElementById('longitudinalDiffXMin');
    const longitudinalDiffXMax = document.getElementById('longitudinalDiffXMax');
    const longitudinalDiffXMinSlider = document.getElementById('longitudinalDiffXMinSlider');
    const longitudinalDiffXMaxSlider = document.getElementById('longitudinalDiffXMaxSlider');
    const longitudinalDiffXAuto = document.getElementById('longitudinalDiffXAuto');
    const longitudinalTimeWidth = document.getElementById('longitudinalTimeWidth');
    const longitudinalTimeHeight = document.getElementById('longitudinalTimeHeight');
    const longitudinalDiffWidth = document.getElementById('longitudinalDiffWidth');
    const longitudinalDiffHeight = document.getElementById('longitudinalDiffHeight');
    const longitudinalTimeReset = document.getElementById('longitudinalTimeReset');
    const longitudinalDiffReset = document.getElementById('longitudinalDiffReset');
    const longitudinalHandles = document.querySelectorAll('.longitudinal-handle');
    const longitudinalTimeWrapper = document.getElementById('longitudinalTimeWrapper');
    const longitudinalDiffWrapper = document.getElementById('longitudinalDiffWrapper');

    if (longitudinalRawInput) {
        longitudinalRawInput.addEventListener('change', (evt) => {
            const file = evt.target.files[0];
            if (!file) return;
            document.getElementById('plotMode').value = 'longitudinal';
            setPlotMode();
            const reader = new FileReader();
            reader.onload = () => loadLongitudinalRawText(reader.result);
            reader.readAsText(file);
        });
    }
    if (longitudinalPosteriorInput) {
        longitudinalPosteriorInput.addEventListener('change', (evt) => {
            const file = evt.target.files[0];
            if (!file) return;
            document.getElementById('plotMode').value = 'longitudinal';
            setPlotMode();
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const data = JSON.parse(reader.result);
                    loadLongitudinalPosteriorJson(data);
                } catch (err) {
                    longitudinalSetStatus('Failed to parse posterior JSON.');
                }
            };
            reader.readAsText(file);
        });
    }
    if (longitudinalCiSlider) {
        longitudinalCiSlider.addEventListener('input', () => {
            longitudinalState.ci = parseFloat(longitudinalCiSlider.value);
            longitudinalUpdateReadout();
            updateLongitudinalPlots();
        });
    }
    if (longitudinalLegendSize) longitudinalLegendSize.value = longitudinalState.legendFontSize;
    if (longitudinalAxisWidth) longitudinalAxisWidth.value = longitudinalState.axisStrokeWidth;
    if (longitudinalLineWidth) longitudinalLineWidth.value = longitudinalState.lineWidth;
    if (longitudinalCiLineWidth) longitudinalCiLineWidth.value = longitudinalState.ciLineWidth;
    if (longitudinalLegendSize) {
        longitudinalLegendSize.addEventListener('input', () => {
            longitudinalState.legendFontSize = parseFloat(longitudinalLegendSize.value) || 11;
            updateLongitudinalPlots();
        });
    }
    if (longitudinalAxisWidth) {
        longitudinalAxisWidth.addEventListener('input', () => {
            longitudinalState.axisStrokeWidth = parseFloat(longitudinalAxisWidth.value) || 1;
            updateLongitudinalPlots();
        });
    }
    if (longitudinalLineWidth) {
        longitudinalLineWidth.addEventListener('input', () => {
            longitudinalState.lineWidth = parseFloat(longitudinalLineWidth.value) || 2;
            updateLongitudinalPlots();
        });
    }
    if (longitudinalCiLineWidth) {
        longitudinalCiLineWidth.addEventListener('input', () => {
            longitudinalState.ciLineWidth = parseFloat(longitudinalCiLineWidth.value) || 2;
            updateLongitudinalPlots();
        });
    }
    if (longitudinalTimeYMin && longitudinalTimeYMax) {
        longitudinalTimeYMin.addEventListener('change', () => {
            longitudinalState.axisRanges.time.auto = false;
            longitudinalState.axisRanges.time.min = parseFloat(longitudinalTimeYMin.value);
            updateLongitudinalPlots();
        });
        longitudinalTimeYMax.addEventListener('change', () => {
            longitudinalState.axisRanges.time.auto = false;
            longitudinalState.axisRanges.time.max = parseFloat(longitudinalTimeYMax.value);
            updateLongitudinalPlots();
        });
    }
    if (longitudinalTimeYMinSlider && longitudinalTimeYMaxSlider) {
        longitudinalTimeYMinSlider.addEventListener('input', () => {
            longitudinalState.axisRanges.time.auto = false;
            longitudinalState.axisRanges.time.min = parseFloat(longitudinalTimeYMinSlider.value);
            updateLongitudinalPlots();
        });
        longitudinalTimeYMaxSlider.addEventListener('input', () => {
            longitudinalState.axisRanges.time.auto = false;
            longitudinalState.axisRanges.time.max = parseFloat(longitudinalTimeYMaxSlider.value);
            updateLongitudinalPlots();
        });
    }
    if (longitudinalTimeYAuto) {
        longitudinalTimeYAuto.addEventListener('click', () => {
            longitudinalState.axisRanges.time.auto = true;
            longitudinalState.axisRanges.time.min = null;
            longitudinalState.axisRanges.time.max = null;
            updateLongitudinalPlots();
        });
    }
    if (longitudinalDiffXMin && longitudinalDiffXMax) {
        longitudinalDiffXMin.addEventListener('change', () => {
            longitudinalState.axisRanges.diff.auto = false;
            longitudinalState.axisRanges.diff.min = parseFloat(longitudinalDiffXMin.value);
            updateLongitudinalPlots();
        });
        longitudinalDiffXMax.addEventListener('change', () => {
            longitudinalState.axisRanges.diff.auto = false;
            longitudinalState.axisRanges.diff.max = parseFloat(longitudinalDiffXMax.value);
            updateLongitudinalPlots();
        });
    }
    if (longitudinalDiffXMinSlider && longitudinalDiffXMaxSlider) {
        longitudinalDiffXMinSlider.addEventListener('input', () => {
            longitudinalState.axisRanges.diff.auto = false;
            longitudinalState.axisRanges.diff.min = parseFloat(longitudinalDiffXMinSlider.value);
            updateLongitudinalPlots();
        });
        longitudinalDiffXMaxSlider.addEventListener('input', () => {
            longitudinalState.axisRanges.diff.auto = false;
            longitudinalState.axisRanges.diff.max = parseFloat(longitudinalDiffXMaxSlider.value);
            updateLongitudinalPlots();
        });
    }
    if (longitudinalDiffXAuto) {
        longitudinalDiffXAuto.addEventListener('click', () => {
            longitudinalState.axisRanges.diff.auto = true;
            longitudinalState.axisRanges.diff.min = null;
            longitudinalState.axisRanges.diff.max = null;
            updateLongitudinalPlots();
        });
    }
    if (longitudinalTimeWidth && longitudinalTimeHeight) {
        longitudinalTimeWidth.addEventListener('change', () => {
            longitudinalState.sizes.time.width = Math.max(300, parseInt(longitudinalTimeWidth.value, 10) || 900);
            updateLongitudinalPlots();
        });
        longitudinalTimeHeight.addEventListener('change', () => {
            longitudinalState.sizes.time.height = Math.max(200, parseInt(longitudinalTimeHeight.value, 10) || 360);
            updateLongitudinalPlots();
        });
    }
    if (longitudinalDiffWidth && longitudinalDiffHeight) {
        longitudinalDiffWidth.addEventListener('change', () => {
            longitudinalState.sizes.diff.width = Math.max(300, parseInt(longitudinalDiffWidth.value, 10) || 900);
            updateLongitudinalPlots();
        });
        longitudinalDiffHeight.addEventListener('change', () => {
            longitudinalState.sizes.diff.height = Math.max(200, parseInt(longitudinalDiffHeight.value, 10) || 360);
            updateLongitudinalPlots();
        });
    }
    if (longitudinalTimeReset) {
        longitudinalTimeReset.addEventListener('click', () => {
            longitudinalState.sizes.time.width = 900;
            longitudinalState.sizes.time.height = 360;
            longitudinalState.offsets.time.x = 0;
            longitudinalState.offsets.time.y = 0;
            longitudinalSyncSizeInputs();
            updateLongitudinalPlots();
        });
    }
    if (longitudinalDiffReset) {
        longitudinalDiffReset.addEventListener('click', () => {
            longitudinalState.sizes.diff.width = 900;
            longitudinalState.sizes.diff.height = 360;
            longitudinalState.offsets.diff.x = 0;
            longitudinalState.offsets.diff.y = 0;
            longitudinalSyncSizeInputs();
            updateLongitudinalPlots();
        });
    }

    let resizing = false;
    let activeTarget = null;
    let activeHandle = null;
    let startX = 0;
    let startY = 0;
    let startW = 0;
    let startH = 0;
    let startOffsetX = 0;
    let startOffsetY = 0;

    longitudinalHandles.forEach((handle) => {
        handle.addEventListener('mousedown', (e) => {
            resizing = true;
            activeTarget = handle.dataset.target;
            activeHandle = handle.dataset.handle;
            startX = e.clientX;
            startY = e.clientY;
            const size = longitudinalState.sizes[activeTarget];
            startW = size.width;
            startH = size.height;
            const offset = longitudinalState.offsets[activeTarget];
            startOffsetX = offset.x;
            startOffsetY = offset.y;
            e.preventDefault();
        });
    });

    if (longitudinalTimeWrapper) {
        longitudinalTimeWrapper.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('longitudinal-handle')) return;
            activeTarget = 'time';
            startX = e.clientX;
            startY = e.clientY;
            startOffsetX = longitudinalState.offsets.time.x;
            startOffsetY = longitudinalState.offsets.time.y;
            const onMove = (evt) => {
                const dx = evt.clientX - startX;
                const dy = evt.clientY - startY;
                longitudinalState.offsets.time.x = startOffsetX + dx;
                longitudinalState.offsets.time.y = startOffsetY + dy;
                updateLongitudinalPlots();
            };
            const onUp = () => {
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('mouseup', onUp);
            };
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
        });
    }
    if (longitudinalDiffWrapper) {
        longitudinalDiffWrapper.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('longitudinal-handle')) return;
            activeTarget = 'diff';
            startX = e.clientX;
            startY = e.clientY;
            startOffsetX = longitudinalState.offsets.diff.x;
            startOffsetY = longitudinalState.offsets.diff.y;
            const onMove = (evt) => {
                const dx = evt.clientX - startX;
                const dy = evt.clientY - startY;
                longitudinalState.offsets.diff.x = startOffsetX + dx;
                longitudinalState.offsets.diff.y = startOffsetY + dy;
                updateLongitudinalPlots();
            };
            const onUp = () => {
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('mouseup', onUp);
            };
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
        });
    }

    window.addEventListener('mousemove', (e) => {
        if (!resizing || !activeTarget) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        let newW = startW;
        let newH = startH;
        if (activeHandle === 'tr' || activeHandle === 'br') newW = startW + dx;
        if (activeHandle === 'tl' || activeHandle === 'bl') {
            newW = startW - dx;
            longitudinalState.offsets[activeTarget].x = startOffsetX + dx;
        }
        if (activeHandle === 'bl' || activeHandle === 'br') newH = startH + dy;
        if (activeHandle === 'tl' || activeHandle === 'tr') {
            newH = startH - dy;
            longitudinalState.offsets[activeTarget].y = startOffsetY + dy;
        }
        longitudinalState.sizes[activeTarget].width = Math.max(300, Math.round(newW));
        longitudinalState.sizes[activeTarget].height = Math.max(200, Math.round(newH));
        longitudinalSyncSizeInputs();
        updateLongitudinalPlots();
    });
    window.addEventListener('mouseup', () => {
        resizing = false;
        activeTarget = null;
        activeHandle = null;
    });
    [longitudinalIdCol, longitudinalGroupCol, longitudinalTimeCol, longitudinalYCol].forEach((input) => {
        if (!input) return;
        input.addEventListener('change', () => {
            if (longitudinalState.raw) loadLongitudinalRawText(longitudinalState.raw);
        });
    });
    document.querySelectorAll('[data-longitudinal-export]').forEach((btn) => {
        btn.addEventListener('click', async () => {
            const svgId = btn.dataset.longitudinalExport;
            const format = (btn.dataset.format || 'svg').toLowerCase();
            const suffix = svgId === 'longitudinalTimePlot' ? 'time-course' : 'difference-density';
            const base = `${getExportBaseName('longitudinal')}_${suffix}`;
            try {
                await exportSvgById(svgId, format, base);
            } catch (err) {
                alert(`Export failed: ${err.message || err}`);
            }
        });
    });
    longitudinalUpdateReadout();
    const svgContainer = document.getElementById('svg-container');
    let draggingLegend = false;

    if (svgContainer) {
        svgContainer.addEventListener('mousedown', (e) => {
            const target = e.target;
            const legendGroup = target && target.closest ? target.closest('#legend-group') : null;
            if (legendGroup) {
                draggingLegend = true;
                e.preventDefault();
            }
        });
        window.addEventListener('mousemove', (e) => {
            if (!draggingLegend || !plotMetrics) return;
            const legendState = document.getElementById('legendState');
            const svg = svgContainer.querySelector('svg');
            if (!legendState || !svg) return;
            const rect = svg.getBoundingClientRect();
            const scale = rect.width && plotMetrics.width ? (rect.width / plotMetrics.width) : 1;
            const x = (e.clientX - rect.left) / scale - plotMetrics.pL;
            const y = (e.clientY - rect.top) / scale - plotMetrics.pT;
            const xPercent = Math.max(0, Math.min(100, (x / plotMetrics.graphW) * 100));
            const yPercent = Math.max(0, Math.min(100, (y / plotMetrics.graphH) * 100));
            legendState.value = `${xPercent.toFixed(2)},${yPercent.toFixed(2)}`;
            updatePlot();
        });
        window.addEventListener('mouseup', () => {
            draggingLegend = false;
        });
        svgContainer.addEventListener('pointerdown', (e) => {
            if (onAxisLabelPointerDown(e)) return;
            if (onGroupLabelPointerDown(e)) return;
            onBarPointerDown(e);
        });
    }

    const explorerPanel = document.getElementById('explorer-panel');
    const explorerHandle = document.getElementById('explorer-handle');
    const explorerHideBtn = document.getElementById('explorerHideBtn');
    const explorerModeSelect = document.getElementById('explorerMode');
    const explorerAddGroupBtn = document.getElementById('explorerAddGroupBtn');
    if (explorerHandle && explorerPanel) {
        explorerHandle.addEventListener('click', () => {
            explorerPanel.classList.toggle('pinned');
        });
    }
    if (explorerPanel) {
        explorerPanel.addEventListener('mouseenter', () => {
            explorerPanel.classList.add('pinned');
            const plotMode = document.getElementById('plotMode');
            if (explorerModeSelect && plotMode) {
                explorerModeSelect.value = plotMode.value;
            }
        });
    }
    if (explorerHideBtn && explorerPanel) {
        explorerHideBtn.addEventListener('click', () => {
            explorerPanel.classList.remove('pinned');
        });
    }
    if (explorerModeSelect) {
        explorerModeSelect.addEventListener('change', () => {
            const plotMode = document.getElementById('plotMode');
            if (!plotMode) return;
            plotMode.value = explorerModeSelect.value;
            setPlotMode();
            renderStagedGroups();
        });
    }
    if (explorerAddGroupBtn) {
        explorerAddGroupBtn.addEventListener('click', () => {
            addExplorerGroup();
        });
    }
    const explorerDirInput = document.getElementById('explorerDirInput');
    const explorerFileList = document.getElementById('explorerFileList');
    const explorerSheetSelect = document.getElementById('explorerSheetSelect');
    const explorerDropZone = document.getElementById('explorerDropZone');
    if (explorerDirInput) {
        explorerDirInput.addEventListener('change', (e) => {
            handleExplorerFiles(e.target.files || []);
        });
    }
    if (explorerFileList) {
        explorerFileList.addEventListener('change', (e) => {
            const idx = parseInt(e.target.value, 10);
            if (!isNaN(idx) && explorerFiles[idx]) {
                readExplorerFile(explorerFiles[idx]);
            }
        });
    }
    if (explorerSheetSelect) {
        explorerSheetSelect.addEventListener('change', (e) => {
            const name = e.target.value;
            if (name) {
                loadExplorerSheet(name);
            }
        });
    }
    if (explorerDropZone) {
        ['dragover', 'dragenter'].forEach((evt) => {
            explorerDropZone.addEventListener(evt, (e) => {
                e.preventDefault();
                explorerDropZone.classList.add('dragging');
            });
        });
        ['dragleave', 'drop'].forEach((evt) => {
            explorerDropZone.addEventListener(evt, (e) => {
                e.preventDefault();
                explorerDropZone.classList.remove('dragging');
            });
        });
        explorerDropZone.addEventListener('drop', async (e) => {
            const dropped = await collectDroppedFiles(e.dataTransfer);
            handleExplorerFiles(dropped);
        });
    }
    document.addEventListener('click', (e) => {
        const menu = document.getElementById('explorerMenu');
        if (!menu) return;
        if (menu.contains(e.target)) return;
        hideExplorerMenu();
    });
    renderStagedGroups();
    const showBarsBox = document.getElementById('showBars');
    if (showBarsBox) showBarsBox.checked = true;
    syncBarControlsUI();
    document.addEventListener('keydown', (e) => {
        const key = (e.key || '').toLowerCase();
        if ((e.ctrlKey || e.metaKey) && !e.shiftKey && key === 'z') {
            e.preventDefault();
            undoBarChanges();
        } else if ((e.ctrlKey || e.metaKey) && (key === 'y' || (e.shiftKey && key === 'z'))) {
            e.preventDefault();
            redoBarChanges();
        }
    });
    loadSampleComparison();
});

function resetGroups() {
    const container = document.getElementById('groupsContainer');
    container.innerHTML = '';
    groupCount = 0;
    groupOffsetX = [];
    groupLabelOffsetY = [];
}

function loadSampleTimeline() {
    document.getElementById('plotMode').value = 'time';
    setPlotMode();
    setTimeLabels(['Day1', 'Day3', 'Day7', 'Day10']);
    resetGroups();
    addNewGroup("WT", "#ffffff", "Day1\tDay3\tDay7\tDay10\n100\t250\t400\t520\n120\t280\t450\t560\n90\t230\t380\t500");
    addNewGroup("KO", "#ffcccc", "Day1\tDay3\tDay7\tDay10\n80\t150\t200\t240\n70\t140\t220\t260\n85\t160\t190\t230");
    applyActiveProfile();
    updatePlot();
}

function loadSampleComparison() {
    document.getElementById('plotMode').value = 'comparison';
    setPlotMode();
    setTimeLabels(['Data']);
    resetGroups();
    addNewGroup("Control", "#ffffff", "12.1\n11.5\n10.9\n12.8\n11.7");
    addNewGroup("Treatment", "#ffcccc", "15.2\n14.6\n16.1\n15.8\n14.9");
    document.getElementById('showBars').checked = true;
    syncBarControlsUI();
    applyActiveProfile();
    updatePlot();
}

function loadSampleLongitudinal() {
    document.getElementById('plotMode').value = 'longitudinal';
    setPlotMode();
    loadSampleLongitudinalData();
}

function ensureGroupOffsets(len) {
    for (let i = 0; i < len; i++) {
        if (groupOffsetX[i] === undefined || isNaN(groupOffsetX[i])) groupOffsetX[i] = 0;
    }
}

function ensureGroupLabelOffsets(len) {
    for (let i = 0; i < len; i++) {
        if (groupLabelOffsetY[i] === undefined || isNaN(groupLabelOffsetY[i])) groupLabelOffsetY[i] = 0;
    }
}

function snapshotBarState() {
    return { offsets: groupOffsetX.slice(), barWidth: barWidthState };
}

function pushUndoState() {
    const last = undoStack[undoStack.length - 1];
    const snap = snapshotBarState();
    if (last && JSON.stringify(last) === JSON.stringify(snap)) return;
    undoStack.push(snap);
    if (undoStack.length > 50) undoStack.shift();
    redoStack = [];
}

function undoBarChanges() {
    if (!undoStack.length) return;
    const current = snapshotBarState();
    const prev = undoStack.pop();
    redoStack.push(current);
    groupOffsetX = prev.offsets.slice();
    barWidthState = prev.barWidth;
    syncBarControlsUI();
    updatePlot();
}

function redoBarChanges() {
    if (!redoStack.length) return;
    const current = snapshotBarState();
    const next = redoStack.pop();
    undoStack.push(current);
    groupOffsetX = next.offsets.slice();
    barWidthState = next.barWidth;
    syncBarControlsUI();
    updatePlot();
}

function resetBarPositions() {
    pushUndoState();
    groupOffsetX = groupOffsetX.map(() => 0);
    syncBarControlsUI();
    updatePlot();
}

function syncBarControlsUI() {
    const showBars = document.getElementById('showBars');
    const card = document.getElementById('barWidthCard');
    const slider = document.getElementById('barWidthSlider');
    const val = document.getElementById('barWidthValue');
    if (slider) slider.value = barWidthState;
    if (val) val.textContent = Math.round(barWidthState);
    if (card && showBars) {
        card.style.display = showBars.checked ? 'block' : 'none';
    }
}

function handleShowBarsToggle() {
    syncBarControlsUI();
    updatePlot();
}

function syncBarWidthFromSlider() {
    const slider = document.getElementById('barWidthSlider');
    if (!slider) return;
    const val = parseFloat(slider.value);
    if (!isNaN(val) && val !== barWidthState) {
        pushUndoState();
        barWidthState = val;
        redoStack = [];
    }
    syncBarControlsUI();
    updatePlot();
}

function loadSampleSurvival() {
    document.getElementById('plotMode').value = 'survival';
    setPlotMode();
    document.getElementById('survivalData').value = [
        "WT\tS1\t5",
        "WT\tS2\t8",
        "WT\tS3\t9",
        "WT\tS4\t12",
        "WT\tS5\t15",
        "KO\tS1\t4",
        "KO\tS2\t6",
        "KO\tS3\t7",
        "KO\tS4\t10",
        "KO\tS5\t11"
    ].join("\n");
    applyActiveProfile();
    updatePlot();
}

function collectProfile() {
    const mode = document.getElementById('plotMode').value;
    if (mode === 'time') {
        document.querySelectorAll('.group-card').forEach((card) => {
            if (card.dataset.bulkOpen === 'true') return;
            syncTextareaFromTimeGrid(card);
        });
    }
    const groupCards = document.querySelectorAll('.group-card');
    const groups = Array.from(groupCards).map(card => ({
        name: card.querySelector('.group-name-input').value,
        color: card.querySelector('.group-color-input').value,
        data: card.querySelector('.group-data-input').value
    }));
    const showLegendEl = document.getElementById('showLegend');
    const legendFontSizeEl = document.getElementById('legendFontSize');
    const legendStateEl = document.getElementById('legendState');
    const yMaxInputEl = document.getElementById('yMaxInput');
    const survivalXMaxEl = document.getElementById('survivalXMax');
    const timeChecks = document.querySelectorAll('#longitudinalTimeChecklist input[type=checkbox]');
    const groupChecks = document.querySelectorAll('#longitudinalGroupChecklist input[type=checkbox]');
    const longitudinalProfile = {
        columns: {
            id: document.getElementById('longitudinalIdCol')?.value || 'id',
            group: document.getElementById('longitudinalGroupCol')?.value || 'group',
            time: document.getElementById('longitudinalTimeCol')?.value || 'time',
            y: document.getElementById('longitudinalYCol')?.value || 'y'
        },
        source: longitudinalState.source || null,
        ci: longitudinalState.ci,
        controlIdx: longitudinalState.controlIdx,
        legendFontSize: longitudinalState.legendFontSize,
        axisStrokeWidth: longitudinalState.axisStrokeWidth,
        lineWidth: longitudinalState.lineWidth,
        ciLineWidth: longitudinalState.ciLineWidth,
        axisRanges: {
            time: { ...longitudinalState.axisRanges.time },
            diff: { ...longitudinalState.axisRanges.diff }
        },
        sizes: {
            time: { ...longitudinalState.sizes.time },
            diff: { ...longitudinalState.sizes.diff }
        },
        offsets: {
            time: { ...longitudinalState.offsets.time },
            diff: { ...longitudinalState.offsets.diff }
        },
        colors: (longitudinalState.colors || []).slice(),
        selectedTimes: Array.from(timeChecks)
            .filter(cb => cb.checked)
            .map(cb => parseInt(cb.dataset.index, 10))
            .filter(n => !isNaN(n)),
        selectedGroups: Array.from(groupChecks)
            .filter(cb => cb.checked)
            .map(cb => parseInt(cb.dataset.index, 10))
            .filter(n => !isNaN(n))
    };
    if (longitudinalState.raw) {
        longitudinalProfile.rawText = longitudinalState.raw;
    }
    if (Array.isArray(longitudinalState.draws) && longitudinalState.draws.length) {
        longitudinalProfile.posterior = {
            draws: longitudinalState.draws,
            groups: (longitudinalState.groups || []).slice(),
            times: (longitudinalState.times || []).slice()
        };
    }
    return {
        version: 1,
        mode,
        timeLabels: getTimeLabels(),
        survival: {
            xMax: document.getElementById('survivalXMax').value,
            yPercent: document.getElementById('survivalYAxisPercent').checked,
            xAuto: survivalXMaxEl ? survivalXMaxEl.dataset.auto !== 'false' : true
        },
        chartSize: {
            width: document.getElementById('chartWidthVal').value,
            height: document.getElementById('chartHeightVal').value
        },
        yAxis: {
            min: document.getElementById('yMinInput').value,
            max: document.getElementById('yMaxInput').value,
            ticks: document.getElementById('numTicks').value,
            errorType: document.getElementById('errorType').value,
            autoMax: yMaxInputEl ? yMaxInputEl.dataset.auto !== 'false' : true
        },
        labels: {
            title: document.getElementById('chartTitleInput')?.value || '',
            titleItalic: document.getElementById('titleItalic')?.checked || false,
            titleSize: document.getElementById('titleFontSize')?.value || '10',
            x: document.getElementById('xAxisLabel').value,
            y: document.getElementById('yAxisLabel').value,
            xOffset: document.getElementById('xLabelOffset').value,
            yOffset: document.getElementById('yLabelOffset').value,
            xFont: document.getElementById('xAxisFontSize').value,
            yFont: document.getElementById('yAxisFontSize').value
        },
        style: {
            fontX: document.getElementById('fontSizeX').value,
            fontY: document.getElementById('fontSizeY').value,
            dotSize: document.getElementById('dotSize').value,
            jitter: document.getElementById('jitter').value,
            barWidth: barWidthState
        },
        legend: {
            show: showLegendEl ? showLegendEl.checked : true,
            fontSize: legendFontSizeEl ? legendFontSizeEl.value : '10',
            state: legendStateEl ? legendStateEl.value : '95,10'
        },
        dragOffsets: {
            chart: { x: chartOffsetX, y: chartOffsetY },
            title: { x: titleOffsetX, y: titleOffsetY },
            xLabel: { x: xAxisLabelOffsetX, y: xAxisLabelOffsetY },
            yLabel: { x: yAxisLabelOffsetX, y: yAxisLabelOffsetY },
            groupLabels: groupLabelOffsetY.slice()
        },
        barOffsets: groupOffsetX.slice(),
        options: {
            showLines: document.getElementById('showLines').checked,
            showBars: document.getElementById('showBars').checked,
            showSampleLines: document.getElementById('showSampleLines').checked,
            showMean: document.getElementById('showMean').checked,
            showMeanDots: document.getElementById('showMeanDots').checked,
            showErrorBars: document.getElementById('showErrorBars').checked,
            showPostHoc: document.getElementById('showPostHoc').checked,
            autoBrackets: document.getElementById('autoBrackets').checked,
            bracketOffset: document.getElementById('bracketOffset').value
        },
        exportPrefs: {
            fileName: document.getElementById('exportFileName')?.value || '',
            format: document.getElementById('exportFormat')?.value || 'svg'
        },
        groups,
        longitudinal: longitudinalProfile
    };
}

function applyActiveProfile() {
    if (activeProfile) {
        applyProfile(activeProfile);
    }
}

function applyProfile(profile) {
    if (!profile || typeof profile !== 'object') return;
    if (profile.mode) {
        const plotModeEl = document.getElementById('plotMode');
        if (plotModeEl) plotModeEl.value = profile.mode;
        setPlotMode();
    }
    if (profile.timeLabels !== undefined) {
        if (Array.isArray(profile.timeLabels)) {
            setTimeLabels(profile.timeLabels);
        } else {
            const labels = parseTimeLabelText(String(profile.timeLabels || ''));
            setTimeLabels(labels);
        }
        updateTimeLabelsBulk();
    }
    if (profile.survival) {
        const survivalXMax = document.getElementById('survivalXMax');
        if (survivalXMax) {
            survivalXMax.value = profile.survival.xMax || '0';
            const auto = profile.survival.xAuto;
            if (auto === true) survivalXMax.dataset.auto = 'true';
            if (auto === false) survivalXMax.dataset.auto = 'false';
            if (auto === undefined) {
                const maxVal = parseFloat(profile.survival.xMax);
                survivalXMax.dataset.auto = (!maxVal || maxVal <= 0) ? 'true' : 'false';
            }
        }
        document.getElementById('survivalYAxisPercent').checked = !!profile.survival.yPercent;
    }
    if (profile.chartSize) {
        document.getElementById('chartWidthVal').value = profile.chartSize.width || 300;
        document.getElementById('chartHeightVal').value = profile.chartSize.height || 200;
    }
    if (profile.yAxis) {
        document.getElementById('yMinInput').value = profile.yAxis.min ?? '0';
        document.getElementById('yMaxInput').value = profile.yAxis.max ?? '0';
        document.getElementById('numTicks').value = profile.yAxis.ticks ?? '5';
        document.getElementById('errorType').value = profile.yAxis.errorType || 'se';
        setErrorType(profile.yAxis.errorType || 'se');
        const yMaxInputEl = document.getElementById('yMaxInput');
        if (yMaxInputEl) {
            const auto = profile.yAxis.autoMax;
            if (auto === true) yMaxInputEl.dataset.auto = 'true';
            if (auto === false) yMaxInputEl.dataset.auto = 'false';
            if (auto === undefined) {
                const maxVal = parseFloat(profile.yAxis.max);
                yMaxInputEl.dataset.auto = (!maxVal || maxVal <= 0) ? 'true' : 'false';
            }
        }
    }
    if (profile.labels) {
        if (profile.labels.title !== undefined) {
            const mainTitleEl = document.getElementById('chartTitleInput');
            if (mainTitleEl) mainTitleEl.value = profile.labels.title || '';
            updateExplorerTitleDisplay();
        }
        if (profile.labels.titleItalic !== undefined) {
            const italicEl = document.getElementById('titleItalic');
            if (italicEl) italicEl.checked = !!profile.labels.titleItalic;
        }
        if (profile.labels.titleSize !== undefined) {
            const titleSizeEl = document.getElementById('titleFontSize');
            if (titleSizeEl) titleSizeEl.value = profile.labels.titleSize || '10';
        }
        document.getElementById('xAxisLabel').value = profile.labels.x || '';
        document.getElementById('yAxisLabel').value = profile.labels.y || '';
        document.getElementById('xLabelOffset').value = profile.labels.xOffset || '25';
        document.getElementById('yLabelOffset').value = profile.labels.yOffset || '25';
        document.getElementById('xAxisFontSize').value = profile.labels.xFont || '10';
        document.getElementById('yAxisFontSize').value = profile.labels.yFont || '10';
    }
    if (profile.style) {
        document.getElementById('fontSizeX').value = profile.style.fontX || '10';
        document.getElementById('fontSizeY').value = profile.style.fontY || '10';
        document.getElementById('dotSize').value = profile.style.dotSize || '3';
        document.getElementById('jitter').value = profile.style.jitter || '8';
        if (profile.style.barWidth !== undefined) {
            barWidthState = parseFloat(profile.style.barWidth) || barWidthState;
        }
    }
    if (profile.options) {
        document.getElementById('showLines').checked = !!profile.options.showLines;
        document.getElementById('showBars').checked = profile.options.showBars ?? true;
        document.getElementById('showSampleLines').checked = !!profile.options.showSampleLines;
        document.getElementById('showMean').checked = !!profile.options.showMean;
        document.getElementById('showMeanDots').checked = !!profile.options.showMeanDots;
        document.getElementById('showErrorBars').checked = !!profile.options.showErrorBars;
        document.getElementById('showPostHoc').checked = !!profile.options.showPostHoc;
        document.getElementById('autoBrackets').checked = !!profile.options.autoBrackets;
        document.getElementById('bracketOffset').value = profile.options.bracketOffset ?? '0';
    }
    if (profile.exportPrefs) {
        const fileInput = document.getElementById('exportFileName');
        const fmtSelect = document.getElementById('exportFormat');
        if (fileInput && profile.exportPrefs.fileName !== undefined) fileInput.value = profile.exportPrefs.fileName;
        if (fmtSelect && profile.exportPrefs.format !== undefined) fmtSelect.value = profile.exportPrefs.format;
    }
    if (Array.isArray(profile.groups)) {
        resetGroups();
        profile.groups.forEach((g) => {
            addNewGroup(g.name || '', g.color || '', g.data || '');
            const card = document.querySelector('.group-card:last-child');
            if (card) handlePaste(card.id);
        });
    }
    if (Array.isArray(profile.barOffsets)) {
        groupOffsetX = profile.barOffsets.map(v => parseFloat(v) || 0);
    }
    if (Array.isArray(profile.groupLabelOffsets)) {
        groupLabelOffsetY = profile.groupLabelOffsets.map(v => parseFloat(v) || 0);
    }
    if (profile.legend) {
        const showLegendEl = document.getElementById('showLegend');
        const legendFontSizeEl = document.getElementById('legendFontSize');
        const legendStateEl = document.getElementById('legendState');
        if (showLegendEl && profile.legend.show !== undefined) showLegendEl.checked = !!profile.legend.show;
        if (legendFontSizeEl && profile.legend.fontSize !== undefined) legendFontSizeEl.value = profile.legend.fontSize;
        if (legendStateEl && profile.legend.state !== undefined) legendStateEl.value = profile.legend.state;
    }
    if (profile.dragOffsets) {
        if (profile.dragOffsets.title) {
            titleOffsetX = parseFloat(profile.dragOffsets.title.x) || 0;
            titleOffsetY = parseFloat(profile.dragOffsets.title.y) || 0;
        }
        if (profile.dragOffsets.xLabel) {
            xAxisLabelOffsetX = parseFloat(profile.dragOffsets.xLabel.x) || 0;
            xAxisLabelOffsetY = parseFloat(profile.dragOffsets.xLabel.y) || 0;
        }
        if (profile.dragOffsets.yLabel) {
            yAxisLabelOffsetX = parseFloat(profile.dragOffsets.yLabel.x) || 0;
            yAxisLabelOffsetY = parseFloat(profile.dragOffsets.yLabel.y) || 0;
        }
        if (profile.dragOffsets.chart) {
            chartOffsetX = parseFloat(profile.dragOffsets.chart.x) || 0;
            chartOffsetY = parseFloat(profile.dragOffsets.chart.y) || 0;
        }
        if (Array.isArray(profile.dragOffsets.groupLabels) && !Array.isArray(profile.groupLabelOffsets)) {
            groupLabelOffsetY = profile.dragOffsets.groupLabels.map(v => parseFloat(v) || 0);
        }
    }
    if (profile.longitudinal) {
        const l = profile.longitudinal;
        const idCol = document.getElementById('longitudinalIdCol');
        const groupCol = document.getElementById('longitudinalGroupCol');
        const timeCol = document.getElementById('longitudinalTimeCol');
        const yCol = document.getElementById('longitudinalYCol');
        if (l.columns) {
            if (idCol && l.columns.id) idCol.value = l.columns.id;
            if (groupCol && l.columns.group) groupCol.value = l.columns.group;
            if (timeCol && l.columns.time) timeCol.value = l.columns.time;
            if (yCol && l.columns.y) yCol.value = l.columns.y;
        }
        const hasPosterior = l.posterior && Array.isArray(l.posterior.draws) && l.posterior.draws.length;
        const hasRaw = typeof l.rawText === 'string' && l.rawText.trim() !== '';
        if (hasPosterior) {
            loadLongitudinalPosteriorJson(l.posterior);
        } else if (hasRaw) {
            loadLongitudinalRawText(l.rawText);
        }
        if (typeof l.ci === 'number') {
            longitudinalState.ci = l.ci;
            const ciSlider = document.getElementById('longitudinalCiSlider');
            if (ciSlider) ciSlider.value = l.ci;
            longitudinalUpdateReadout();
        }
        if (l.legendFontSize !== undefined) {
            longitudinalState.legendFontSize = parseFloat(l.legendFontSize) || longitudinalState.legendFontSize;
            const el = document.getElementById('longitudinalLegendSize');
            if (el) el.value = longitudinalState.legendFontSize;
        }
        if (l.axisStrokeWidth !== undefined) {
            longitudinalState.axisStrokeWidth = parseFloat(l.axisStrokeWidth) || longitudinalState.axisStrokeWidth;
            const el = document.getElementById('longitudinalAxisWidth');
            if (el) el.value = longitudinalState.axisStrokeWidth;
        }
        if (l.lineWidth !== undefined) {
            longitudinalState.lineWidth = parseFloat(l.lineWidth) || longitudinalState.lineWidth;
            const el = document.getElementById('longitudinalLineWidth');
            if (el) el.value = longitudinalState.lineWidth;
        }
        if (l.ciLineWidth !== undefined) {
            longitudinalState.ciLineWidth = parseFloat(l.ciLineWidth) || longitudinalState.ciLineWidth;
            const el = document.getElementById('longitudinalCiLineWidth');
            if (el) el.value = longitudinalState.ciLineWidth;
        }
        if (l.axisRanges) {
            longitudinalState.axisRanges.time = { ...longitudinalState.axisRanges.time, ...(l.axisRanges.time || {}) };
            longitudinalState.axisRanges.diff = { ...longitudinalState.axisRanges.diff, ...(l.axisRanges.diff || {}) };
        }
        if (l.sizes) {
            longitudinalState.sizes.time = { ...longitudinalState.sizes.time, ...(l.sizes.time || {}) };
            longitudinalState.sizes.diff = { ...longitudinalState.sizes.diff, ...(l.sizes.diff || {}) };
        }
        if (l.offsets) {
            longitudinalState.offsets.time = { ...longitudinalState.offsets.time, ...(l.offsets.time || {}) };
            longitudinalState.offsets.diff = { ...longitudinalState.offsets.diff, ...(l.offsets.diff || {}) };
        }
        if (Array.isArray(l.colors) && l.colors.length) {
            longitudinalState.colors = l.colors.slice();
        }
        if (typeof l.controlIdx === 'number') {
            longitudinalState.controlIdx = l.controlIdx;
            longitudinalSetupControls();
            longitudinalBuildDiffCaches();
        }
        if (Array.isArray(l.selectedTimes)) {
            const timeList = document.getElementById('longitudinalTimeChecklist');
            if (timeList) {
                timeList.querySelectorAll('input[type=checkbox]').forEach((cb) => {
                    const idx = parseInt(cb.dataset.index, 10);
                    cb.checked = l.selectedTimes.includes(idx);
                });
            }
        }
        if (Array.isArray(l.selectedGroups)) {
            const groupList = document.getElementById('longitudinalGroupChecklist');
            if (groupList) {
                groupList.querySelectorAll('input[type=checkbox]').forEach((cb) => {
                    const idx = parseInt(cb.dataset.index, 10);
                    cb.checked = l.selectedGroups.includes(idx);
                });
            }
        }
        longitudinalSyncSizeInputs();
        updateLongitudinalPlots();
    }
    syncBarControlsUI();
    refreshAllGroupTimeGrids();
    updatePlot();
    const svgWrapper = document.getElementById('svg-wrapper');
    if (svgWrapper) {
        svgWrapper.style.transform = `translate(${chartOffsetX}px, ${chartOffsetY}px)`;
    }
    const handlePosLeft = document.getElementById('handlePosLeft');
    if (handlePosLeft) {
        handlePosLeft.textContent = `L: ${Math.round(chartOffsetX)}`;
    }
    renderExplorerMenuGroups();
}

function downloadProfile() {
    const profile = collectProfile();
    const json = JSON.stringify(profile, null, 2);
    const filename = `plot_profile_${new Date().getTime()}.json`;

    const doFallbackDownload = () => {
        const blob = new Blob([json], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
    };

    if (window.showSaveFilePicker) {
        (async () => {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: filename,
                    types: [
                        {
                            description: 'JSON file',
                            accept: { 'application/json': ['.json'] }
                        }
                    ]
                });
                const writable = await handle.createWritable();
                await writable.write(json);
                await writable.close();
                showToast('Saved');
                return;
            } catch (err) {
                if (err && err.name === 'AbortError') return;
            }
            doFallbackDownload();
        })();
    } else {
        doFallbackDownload();
    }
}

function loadProfile(event) {
    const file = event.target.files && event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
        try {
            const profile = JSON.parse(reader.result);
            activeProfile = profile;
            applyProfile(profile);
        } catch (e) {
            alert('Invalid profile JSON');
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

function resetProfile() {
    activeProfile = null;
    const defaultProfile = {
        timeLabels: ['Day1', 'Day3', 'Day7'],
        survival: { xMax: '0', yPercent: false },
        chartSize: { width: '300', height: '200' },
        yAxis: { min: '0', max: '0', ticks: '5', errorType: 'se', autoMax: true },
        labels: { x: '', y: '', titleItalic: false, titleSize: '10', xOffset: '25', yOffset: '25', xFont: '10', yFont: '10' },
        style: { fontX: '10', fontY: '10', dotSize: '3', jitter: '8' },
        legend: { show: true, fontSize: '10', state: '95,10' },
        dragOffsets: {
            chart: { x: 0, y: 0 },
            title: { x: 0, y: 0 },
            xLabel: { x: 0, y: 0 },
            yLabel: { x: 0, y: 0 },
            groupLabels: []
        },
        options: {
            showLines: false,
            showBars: false,
            showSampleLines: false,
            showMean: true,
            showMeanDots: true,
            showErrorBars: true,
            showPostHoc: false,
            autoBrackets: true,
            bracketOffset: '0'
        },
        exportPrefs: {
            fileName: 'MultiGroup_Figure',
            format: 'svg'
        },
        groups: null
    };
    applyProfile(defaultProfile);
    const cards = Array.from(document.querySelectorAll('.group-card'));
    cards.forEach((card, idx) => {
        const colorEl = card.querySelector('.group-color-input');
        if (colorEl) colorEl.value = defaultColors[idx % defaultColors.length];
    });
    document.getElementById('showLegend').checked = true;
    document.getElementById('legendFontSize').value = '10';
    const italicEl = document.getElementById('titleItalic');
    if (italicEl) italicEl.checked = false;
    const titleSizeEl = document.getElementById('titleFontSize');
    if (titleSizeEl) titleSizeEl.value = '10';
    titleOffsetX = 0;
    titleOffsetY = 0;
    xAxisLabelOffsetX = 0;
    xAxisLabelOffsetY = 0;
    yAxisLabelOffsetX = 0;
    yAxisLabelOffsetY = 0;
    chartOffsetX = 0;
    chartOffsetY = 0;
    const svgWrapper = document.getElementById('svg-wrapper');
    if (svgWrapper) {
        svgWrapper.style.transform = `translate(${chartOffsetX}px, ${chartOffsetY}px)`;
    }
    const handlePosLeft = document.getElementById('handlePosLeft');
    if (handlePosLeft) {
        handlePosLeft.textContent = `L: ${Math.round(chartOffsetX)}`;
    }
    document.getElementById('legendState').value = '95,10';
    updatePlot();
}

function removeGroup(id) {
    const el = document.getElementById(id);
    if (el) el.remove();
    renumberGroups();
    updatePlot();
}

function renumberGroups() {
    const cards = document.querySelectorAll('.group-card');
    groupCount = 0;
    cards.forEach((card) => {
        groupCount += 1;
        const newId = `group_${groupCount}`;
        card.id = newId;
        const btn = card.querySelector('.btn-remove');
        if (btn) {
            btn.setAttribute('onclick', `removeGroup('${newId}')`);
        }
    });
}

function handlePaste(id) {
    const card = document.getElementById(id);
    const textarea = card.querySelector('.group-data-input');
    const text = textarea.value.trim();
    if (!text) return;

    const lines = text.split('\n');
    const firstLine = lines[0].split('\t');
    const isHeader = firstLine.some(cell => isNaN(parseFloat(cell)) && cell !== "");
    const hasDayLabel = firstLine.some(cell => /day\s*\d+/i.test(cell));

    if (isHeader && hasDayLabel) {
        setTimeLabels(firstLine);
        textarea.value = lines.slice(1).join('\n');
    }
    renderGroupTable(card);
    if (document.getElementById('plotMode')?.value === 'time') {
        renderGroupTimeGrid(card);
    }
    updatePlot();
}

function parseData(text, expectedCount) {
    const trimmed = text.trim();
    if (!trimmed) return [];

    const lines = trimmed.split('\n');
    if (expectedCount === 1) {
        const values = [];
        lines.forEach(line => {
            line.split(/[\t, ]+/).forEach(cell => {
                const v = parseFloat(cell);
                if (!Number.isNaN(v)) values.push(v);
            });
        });
        return [values];
    }

    let startIdx = 0;
    const firstLineCells = lines[0].split('\t');
    if (firstLineCells.some(cell => isNaN(parseFloat(cell)) && cell !== "")) {
        startIdx = 1;
    }

    const result = Array.from({ length: expectedCount }, () => []);
    for (let i = startIdx; i < lines.length; i++) {
        const values = lines[i].split('\t');
        for (let j = 0; j < expectedCount; j++) {
            if (values[j] !== undefined && values[j].trim() !== "" && !isNaN(values[j])) {
                result[j].push(parseFloat(values[j]));
            }
        }
    }
    return result;
}

let timeLabelState = [];

function parseTimeLabelText(text) {
    return String(text || '').trim().split(/[\t,\n\r\s]+/).filter(Boolean);
}

function getTimeLabels() {
    if (timeLabelState.length) {
        return timeLabelState.filter(l => l !== '');
    }
    const input = document.getElementById('timePointsInput');
    if (!input) return [];
    return input.value.trim().split(/[\t\s]+/).filter(s => s !== '');
}

function syncTimePointsInput() {
    const input = document.getElementById('timePointsInput');
    if (input) input.value = timeLabelState.join(' ');
}

function updateTimeLabelsBulk() {
    const bulk = document.getElementById('timeLabelsBulk');
    if (bulk) bulk.value = timeLabelState.join(' ');
}

function renderTimeLabelInputs() {
    const list = document.getElementById('timeLabelList');
    if (!list) return;
    list.innerHTML = '';
    timeLabelState.forEach((label, idx) => {
        const item = document.createElement('div');
        item.className = 'time-label-item';
        item.dataset.index = String(idx);
        const handle = document.createElement('span');
        handle.className = 'time-label-drag';
        handle.draggable = true;
        handle.dataset.index = String(idx);
        handle.textContent = '⠿';
        const input = document.createElement('input');
        input.type = 'text';
        input.draggable = false;
        input.value = label;
        input.addEventListener('mousedown', (e) => e.stopPropagation());
        input.addEventListener('dragstart', (e) => e.preventDefault());
        input.addEventListener('input', () => {
            timeLabelState[idx] = input.value.trim();
            syncTimePointsInput();
            refreshAllGroupTimeGrids();
            updatePlot();
            renderExplorerTimeSelect();
        });
        const remove = document.createElement('button');
        remove.type = 'button';
        remove.className = 'time-label-remove';
        remove.textContent = '×';
        remove.addEventListener('click', () => {
            timeLabelState.splice(idx, 1);
            syncTimePointsInput();
            renderTimeLabelInputs();
            refreshAllGroupTimeGrids();
            updatePlot();
            renderExplorerTimeSelect();
        });
        item.appendChild(handle);
        item.appendChild(input);
        item.appendChild(remove);
        list.appendChild(item);
    });
    bindTimeLabelDrag(list);
    updateTimeLabelsBulk();
}

function setTimeLabels(labels) {
    timeLabelState = (labels || []).map(l => String(l || '').trim()).filter(l => l !== '');
    if (timeLabelState.length === 0) {
        timeLabelState = [];
    }
    syncTimePointsInput();
    renderTimeLabelInputs();
    refreshAllGroupTimeGrids();
    renderExplorerTimeSelect();
}

function addTimeLabel(label = '') {
    timeLabelState.push(label || `Time${timeLabelState.length + 1}`);
    syncTimePointsInput();
    renderTimeLabelInputs();
    refreshAllGroupTimeGrids();
    updatePlot();
    renderExplorerTimeSelect();
}

function applyTimeLabelsBulk() {
    const bulk = document.getElementById('timeLabelsBulk');
    if (!bulk) return;
    const labels = parseTimeLabelText(bulk.value);
    if (!labels.length) return;
    setTimeLabels(labels);
}

function buildMatrixFromColumns(columns) {
    const maxRows = Math.max(0, ...columns.map(col => col.length));
    const lines = [];
    for (let i = 0; i < maxRows; i++) {
        const row = columns.map(col => (col[i] ?? '').toString().trim());
        if (row.some(cell => cell !== '')) {
            lines.push(row.join('\t').trimEnd());
        }
    }
    return lines.join('\n');
}

function reorderArray(arr, fromIdx, toIdx) {
    const next = arr.slice();
    const [moved] = next.splice(fromIdx, 1);
    next.splice(toIdx, 0, moved);
    return next;
}

function reorderTimeLabels(fromIdx, toIdx) {
    if (fromIdx === toIdx) return;
    const oldLabels = timeLabelState.slice();
    if (fromIdx < 0 || toIdx < 0 || fromIdx >= oldLabels.length || toIdx >= oldLabels.length) return;
    const order = reorderArray(oldLabels.map((_, idx) => idx), fromIdx, toIdx);
    timeLabelState = order.map(i => oldLabels[i]);
    syncTimePointsInput();
    document.querySelectorAll('.group-card').forEach((card) => {
        const textarea = card.querySelector('.group-data-input');
        if (!textarea) return;
        const columns = parseData(textarea.value, oldLabels.length);
        const reordered = order.map(i => columns[i] || []);
        textarea.value = buildMatrixFromColumns(reordered);
    });
    renderTimeLabelInputs();
    refreshAllGroupTimeGrids();
    updatePlot();
    renderExplorerTimeSelect();
}

function reorderStagedTimeLabels(fromIdx, toIdx) {
    if (fromIdx === toIdx) return;
    const oldLabels = stagedTimeLabels.slice();
    if (fromIdx < 0 || toIdx < 0 || fromIdx >= oldLabels.length || toIdx >= oldLabels.length) return;
    const order = reorderArray(oldLabels.map((_, idx) => idx), fromIdx, toIdx);
    stagedTimeLabels = order.map(i => oldLabels[i]);
    Object.keys(stagedGroups).forEach((key) => {
        const text = stagedGroups[key] || '';
        const columns = parseData(text, oldLabels.length);
        const reordered = order.map(i => columns[i] || []);
        stagedGroups[key] = buildMatrixFromColumns(reordered);
    });
    renderStagedGroups();
    renderExplorerTimeSelect();
}

function bindTimeLabelDrag(listEl) {
    if (!listEl) return;
    listEl.querySelectorAll('.time-label-item').forEach((item) => {
        item.addEventListener('dragover', (e) => {
            if (!e.dataTransfer || !e.dataTransfer.types || !Array.from(e.dataTransfer.types).includes('text/plain')) return;
            e.preventDefault();
        });
        item.addEventListener('drop', (e) => {
            if (!e.dataTransfer || !e.dataTransfer.types || !Array.from(e.dataTransfer.types).includes('text/plain')) return;
            e.preventDefault();
            const from = parseInt(e.dataTransfer.getData('text/plain'), 10);
            const to = parseInt(item.dataset.index || '0', 10);
            if (!isNaN(from) && !isNaN(to)) {
                reorderTimeLabels(from, to);
            }
        });
    });
    listEl.querySelectorAll('.time-label-drag').forEach((handle) => {
        handle.addEventListener('dragstart', (e) => {
            handle.classList.add('dragging');
            e.dataTransfer.setData('text/plain', handle.dataset.index || '0');
        });
        handle.addEventListener('dragend', () => {
            handle.classList.remove('dragging');
        });
    });
}

function bindStagedTimeLabelDrag(listEl) {
    if (!listEl) return;
    listEl.querySelectorAll('.time-label-item').forEach((item) => {
        item.addEventListener('dragover', (e) => {
            if (!e.dataTransfer || !e.dataTransfer.types || !Array.from(e.dataTransfer.types).includes('text/plain')) return;
            e.preventDefault();
        });
        item.addEventListener('drop', (e) => {
            if (!e.dataTransfer || !e.dataTransfer.types || !Array.from(e.dataTransfer.types).includes('text/plain')) return;
            e.preventDefault();
            const from = parseInt(e.dataTransfer.getData('text/plain'), 10);
            const to = parseInt(item.dataset.index || '0', 10);
            if (!isNaN(from) && !isNaN(to)) {
                reorderStagedTimeLabels(from, to);
            }
        });
    });
    listEl.querySelectorAll('.time-label-drag').forEach((handle) => {
        handle.addEventListener('dragstart', (e) => {
            handle.classList.add('dragging');
            e.dataTransfer.setData('text/plain', handle.dataset.index || '0');
        });
        handle.addEventListener('dragend', () => {
            handle.classList.remove('dragging');
        });
    });
}

function syncTextareaFromTimeGrid(card) {
    const grid = card.querySelector('.group-time-grid');
    const textarea = card.querySelector('.group-data-input');
    if (!grid || !textarea) return;
    const columns = Array.from(grid.querySelectorAll('.group-time-col textarea')).map((ta) => (
        ta.value.split(/\r?\n/).map(v => v.trim()).filter(v => v !== '')
    ));
    textarea.value = buildMatrixFromColumns(columns);
}

function renderGroupTimeGrid(card) {
    if (!card) return;
    const grid = card.querySelector('.group-time-grid');
    const textarea = card.querySelector('.group-data-input');
    const preview = card.querySelector('.paste-preview');
    if (!grid || !textarea) return;
    const labels = getTimeLabels();
    if (!labels.length) {
        grid.style.display = 'none';
        textarea.style.display = '';
        if (preview) preview.style.display = '';
        return;
    }
    const bulkOpen = card.dataset.bulkOpen === 'true';
    if (bulkOpen) {
        grid.style.display = 'none';
        textarea.style.display = '';
        if (preview) preview.style.display = '';
        renderGroupTable(card);
        return;
    }
    grid.style.display = '';
    textarea.style.display = 'none';
    if (preview) preview.style.display = 'none';
    const existingCols = {};
    grid.querySelectorAll('.group-time-col').forEach((col) => {
        const label = col.dataset.label;
        const ta = col.querySelector('textarea');
        existingCols[label] = ta ? ta.value : '';
    });
    const parsed = parseData(textarea.value, labels.length);
    grid.innerHTML = '';
    labels.forEach((label, idx) => {
        const col = document.createElement('div');
        col.className = 'group-time-col';
        col.dataset.label = label;
        col.dataset.index = String(idx);
        col.draggable = true;
        const lab = document.createElement('label');
        lab.textContent = label || `Time${idx + 1}`;
        const ta = document.createElement('textarea');
        const existing = existingCols[label];
        if (existing !== undefined && existing !== '') {
            ta.value = existing;
        } else {
            ta.value = (parsed[idx] || []).join('\n');
        }
        ta.addEventListener('input', () => {
            syncTextareaFromTimeGrid(card);
            updatePlot();
        });
        col.appendChild(lab);
        col.appendChild(ta);
        grid.appendChild(col);
    });
    bindGroupTimeDrag(grid);
}

function refreshAllGroupTimeGrids() {
    document.querySelectorAll('.group-card').forEach((card) => {
        renderGroupTimeGrid(card);
    });
}

function toggleGroupBulkEdit(id) {
    const card = document.getElementById(id);
    if (!card) return;
    const mode = document.getElementById('plotMode')?.value || 'comparison';
    if (mode !== 'time') return;
    const grid = card.querySelector('.group-time-grid');
    const textarea = card.querySelector('.group-data-input');
    const preview = card.querySelector('.paste-preview');
    if (!grid || !textarea) return;
    const open = card.dataset.bulkOpen === 'true';
    if (open) {
        card.dataset.bulkOpen = 'false';
        textarea.style.display = 'none';
        if (preview) preview.style.display = 'none';
        renderGroupTimeGrid(card);
    } else {
        card.dataset.bulkOpen = 'true';
        grid.style.display = 'none';
        textarea.style.display = '';
        if (preview) preview.style.display = '';
        renderGroupTable(card);
    }
}

function bindGroupTimeDrag(grid) {
    if (!grid) return;
    grid.querySelectorAll('.group-time-col').forEach((col) => {
        col.addEventListener('dragstart', (e) => {
            col.classList.add('dragging');
            e.dataTransfer.setData('text/plain', col.dataset.index || '0');
        });
        col.addEventListener('dragend', () => {
            col.classList.remove('dragging');
        });
        col.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        col.addEventListener('drop', (e) => {
            e.preventDefault();
            const from = parseInt(e.dataTransfer.getData('text/plain'), 10);
            const to = parseInt(col.dataset.index || '0', 10);
            if (!isNaN(from) && !isNaN(to)) {
                reorderTimeLabels(from, to);
            }
        });
    });
}

function getColumnCount(text) {
    const line = text.trim().split('\n').find(l => l.trim() !== "");
    if (!line) return 0;
    return line.split('\t').length;
}

function renderGroupTable(card) {
    if (!card) return;
    const textarea = card.querySelector('.group-data-input');
    const preview = card.querySelector('.paste-preview');
    if (!textarea || !preview) return;
    const text = textarea.value.trim();
    if (!text) {
        preview.innerHTML = '';
        return;
    }
    const mode = document.getElementById('plotMode').value;
    const timeLabels = mode === 'comparison'
        ? ["Data"]
        : getTimeLabels();
    const colCount = timeLabels.length > 0 ? timeLabels.length : getColumnCount(text);
    if (colCount === 0) {
        preview.innerHTML = '';
        return;
    }
    const data = parseData(text, colCount);
    const maxRows = Math.max(...data.map(arr => arr.length), 0);
    const headers = timeLabels.length > 0 ? timeLabels : Array.from({ length: colCount }, (_, i) => `Col${i + 1}`);
    let html = '<table><thead><tr>';
    headers.forEach(h => { html += `<th>${h}</th>`; });
    html += '</tr></thead><tbody>';
    for (let r = 0; r < maxRows; r++) {
        html += '<tr>';
        for (let c = 0; c < colCount; c++) {
            const val = data[c][r];
            html += `<td>${val !== undefined ? val : ''}</td>`;
        }
        html += '</tr>';
    }
    html += '</tbody></table>';
    preview.innerHTML = html;
}

function calcStats(arr) {
    const n = arr.length;
    if (n === 0) return { mean: 0, sd: 0, se: 0, n: 0 };
    const mean = arr.reduce((a, b) => a + b, 0) / n;
    const variance = n > 1 ? arr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (n - 1) : 0;
    const sd = Math.sqrt(variance);
    return { mean, sd, se: sd / Math.sqrt(n), n };
}

// --- 統計計算ユーチEリチE ---

// 1. Welch's t-test (2群の平坁Eの比輁E
function welchTTest(a, b) {
    const s1 = calcStats(a), s2 = calcStats(b);
    if (s1.n < 2 || s2.n < 2) return null;
    const v1 = Math.pow(s1.sd, 2), v2 = Math.pow(s2.sd, 2);
    const t = Math.abs(s1.mean - s2.mean) / Math.sqrt(v1 / s1.n + v2 / s2.n);
    const df = Math.pow(v1 / s1.n + v2 / s2.n, 2) / (Math.pow(v1 / s1.n, 2) / (s1.n - 1) + Math.pow(v2 / s2.n, 2) / (s2.n - 1));
    const p = 2 * (1 - tDistributionCDF(Math.abs(t), df));
    return { t, p, df, method: "Welch's t-test" };
}

// 2. One-way ANOVA (3群以上E比輁E
function oneWayANOVA(groupsData) {
    const validGroups = groupsData.filter(g => g.length > 1);
    if (validGroups.length < 3) return null;

    const allData = validGroups.flat();
    const grandMean = allData.reduce((a, b) => a + b, 0) / allData.length;

    let ssBetween = 0, ssWithin = 0;
    validGroups.forEach(group => {
        const m = group.reduce((a, b) => a + b, 0) / group.length;
        ssBetween += group.length * Math.pow(m - grandMean, 2);
        group.forEach(v => { ssWithin += Math.pow(v - m, 2); });
    });

    const dfBetween = validGroups.length - 1;
    const dfWithin = allData.length - validGroups.length;
    const msBetween = ssBetween / dfBetween;
    const msWithin = ssWithin / dfWithin;
    const f = msBetween / msWithin;

    return { f, df1: dfBetween, df2: dfWithin, msWithin, method: "One-way ANOVA" };
}

// 3. Brunner-Munzel Test (非パラメトリチE)
function brunnerMunzel(x, y) {
    const n1 = x.length, n2 = y.length;
    if (n1 < 2 || n2 < 2) return { p: 1.0, w: 0 };

    const combined = [...x.map(v => ({ v, g: 1 })), ...y.map(v => ({ v, g: 2 }))].sort((a, b) => a.v - b.v);
    for (let i = 0; i < combined.length; ) {
        let j = i + 1;
        while (j < combined.length && combined[j].v === combined[i].v) j += 1;
        const rank = (i + 1 + j) / 2;
        for (let k = i; k < j; k++) combined[k].r = rank;
        i = j;
    }

    const r1 = combined.filter(d => d.g === 1).map(d => d.r);
    const r2 = combined.filter(d => d.g === 2).map(d => d.r);

    const m1 = r1.reduce((a, b) => a + b, 0) / n1;
    const m2 = r2.reduce((a, b) => a + b, 0) / n2;

    const v1 = r1.reduce((sum, ri) => sum + Math.pow(ri - m1, 2), 0) / (n1 - 1);
    const v2 = r2.reduce((sum, rj) => sum + Math.pow(rj - m2, 2), 0) / (n2 - 1);

    const denom = Math.sqrt(v1 / n1 + v2 / n2);
    if (!Number.isFinite(denom) || denom === 0) return { p: 1.0, w: 0, df: 0 };
    const w = (m1 - m2) / denom;

    const df = Math.pow(v1 / n1 + v2 / n2, 2)
        / (Math.pow(v1 / n1, 2) / (n1 - 1) + Math.pow(v2 / n2, 2) / (n2 - 1));

    const p = 2 * (1 - tDistributionCDF(Math.abs(w), df));
    return { p, w, df };
}

// 標準正規E币EE累積E币E数 (p値算E用)
function normalCDF(x) {
    const t = 1 / (1 + 0.2316419 * Math.abs(x));
    const d = 0.3989423 * Math.exp(-x * x / 2);
    const p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + 1.330274 * t))));
    return x > 0 ? 1 - p : p;
}

function tDistributionCDF(t, df) {
    if (!Number.isFinite(t) || !Number.isFinite(df) || df <= 0) return NaN;
    const x = df / (df + t * t);
    const a = df / 2;
    const b = 0.5;
    const ib = ibeta(x, a, b);
    return t >= 0 ? 1 - 0.5 * ib : 0.5 * ib;
}

function niceCeil(val) {
    if (val <= 0) return 10;
    const exp = Math.pow(10, Math.floor(Math.log10(val)));
    let first = Math.floor(val / exp);
    const second = Math.floor((val / exp - first) * 10);
    if (second > 0) first += 1;
    return first * exp;
}

// 正剁E完EベEタ関数の近似ロジチEE統計関数で共通利用EE
function ibeta(x, a, b) {
    let bt = (x > 0 && x < 1) ? Math.exp(logGamma(a + b) - logGamma(a) - logGamma(b) + a * Math.log(x) + b * Math.log(1 - x)) : 0;
    if (x < (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;
    return 1 - bt * betacf(1 - x, b, a) / b;
}
function logGamma(z) {
    const c = [76.18009172947146, -86.50532032941677, 24.01409824083091, -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5];
    let x = y = z, tmp = x + 5.5;
    tmp -= (x + 0.5) * Math.log(tmp);
    let ser = 1.000000000190015;
    for (let i = 0; i < 6; i++) ser += c[i] / ++y;
    return -tmp + Math.log(2.5066282746310005 * ser / x);
}
function betacf(x, a, b) {
    let qab = a + b, qap = a + 1, qam = a - 1, c = 1, d = 1 - qab * x / qap;
    if (Math.abs(d) < 1e-10) d = 1e-10;
    d = 1 / d;
    let h = d;
    for (let m = 1; m <= 100; m++) {
        let m2 = 2 * m, aa = m * (b - m) * x / ((qam + m2) * (a + m2));
        d = 1 + aa * d; if (Math.abs(d) < 1e-10) d = 1e-10;
        c = 1 + aa / c; if (Math.abs(c) < 1e-10) c = 1e-10;
        d = 1 / d; h *= d * c;
        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
        d = 1 + aa * d; if (Math.abs(d) < 1e-10) d = 1e-10;
        c = 1 + aa / c; if (Math.abs(c) < 1e-10) c = 1e-10;
        d = 1 / d; h *= d * c;
        if (Math.abs(h - 1) < 1e-7) break;
    }
    return h;
}

// --- 追加EF刁EEらP値を算Eする関数EENOVA用EE---
function fDistributionP(F, df1, df2) {
    if (F <= 0) return 1.0;
    // 簡易的な不完EベEタ関数による近似EEanilla JSでの実裁EE
    const x = df2 / (df2 + df1 * F);
    const a = df2 / 2;
    const b = df1 / 2;

    return ibeta(x, a, b);
}

// --- Dunnett's Test 簡易実裁E(Control vs Others) ---
function runDunnett(groupsData, msWithin, dfWithin) {
    const control = groupsData[0];
    const results = [];
    const n1 = control.length;
    const mean1 = control.reduce((a, b) => a + b, 0) / n1;

    for (let i = 1; i < groupsData.length; i++) {
        const treat = groupsData[i];
        const n2 = treat.length;
        const mean2 = treat.reduce((a, b) => a + b, 0) / n2;

        // 標準誤差 (ANOVAのMSwithinを使用)
        const se = Math.sqrt(msWithin * (1 / n1 + 1 / n2));
        const tVal = Math.abs(mean1 - mean2) / se;

        // P値の近似 (Bonferroni調整を加えたt刁EE似)
        const k = groupsData.length - 1;
        const rawP = 2 * (1 - studentTCDF(tVal, dfWithin));
        const adjustedP = Math.min(1.0, rawP * k);

        results.push({
            targetName: `Group ${i + 1}`,
            p: adjustedP,
            isSig: adjustedP < 0.05
        });
    }
    return results;
}

// 自由度dfのt刁EE積E币E数 (簡易近似)
function studentTCDF(t, df) {
    const x = df / (df + t * t);
    return 1 - 0.5 * ibeta(x, df / 2, 0.5);
}

// P値に応じたアスタリスクを返す
function getStars(p) {
    if (p < 0.01) return "**";
    if (p < 0.05) return "*";
    return "";
}

function getCssVar(name) {
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

// ブラケチE描画用の関数
function drawBracket(x1, x2, y, stars, fontSize) {
    const tickH = 6; // カギ線E端の長ぁE
    const axisColor = getCssVar('--svg-ink') || 'black';
    return `
    <g class="sig-bracket" stroke="${axisColor}" fill="none" stroke-width="1.2">
        <path d="M ${x1} ${y} L ${x1} ${y - tickH} L ${x2} ${y - tickH} L ${x2} ${y}" />
        <text x="${(x1 + x2) / 2}" y="${y - tickH - 2}" fill="${axisColor}" stroke="none"
              text-anchor="middle" font-size="${fontSize * 1.2}" font-family="Arial" font-weight="bold">${stars}</text>
    </g>`;
}

function updateCodeDisplay() {
    const code = `// --- Analysis Logic Used ---
// 1. Welch's T-Test: assumes unequal variance.
// 2. Brunner-Munzel: robust non-parametric test.

${brunnerMunzel.toString()}

${welchTTest.toString()}`;
    document.getElementById('codeDisplay').textContent = code;
}

function setPlotMode() {
    const mode = document.getElementById('plotMode').value;
    const explorerMode = document.getElementById('explorerMode');
    const timeInput = document.getElementById('timePointsInput');
    const groupSection = document.getElementById('groupDataSection');
    const survivalSection = document.getElementById('survivalSection');
    const timeSeriesSection = document.getElementById('timeSeriesSection');
    const longitudinalSection = document.getElementById('longitudinalSection');
    const longitudinalArea = document.getElementById('longitudinalArea');
    const previewRow = document.querySelector('.preview-row');
    const statsPanels = document.querySelectorAll('.stats-panel');
    const yMaxInputEl = document.getElementById('yMaxInput');

    if (explorerMode) explorerMode.value = mode;
    if (mode === 'longitudinal') {
        if (timeInput) timeInput.disabled = true;
        if (groupSection) groupSection.style.display = 'none';
        if (survivalSection) survivalSection.style.display = 'none';
        if (timeSeriesSection) timeSeriesSection.style.display = 'none';
        if (longitudinalSection) longitudinalSection.style.display = '';
        if (previewRow) previewRow.style.display = 'none';
        if (longitudinalArea) longitudinalArea.style.display = 'flex';
        statsPanels.forEach(panel => panel.style.display = 'none');
    } else if (mode === 'survival') {
        if (timeInput) timeInput.disabled = true;
        if (groupSection) groupSection.style.display = 'none';
        if (survivalSection) survivalSection.style.display = '';
        if (timeSeriesSection) timeSeriesSection.style.display = 'none';
        if (longitudinalSection) longitudinalSection.style.display = 'none';
        if (previewRow) previewRow.style.display = '';
        if (longitudinalArea) longitudinalArea.style.display = 'none';
        statsPanels.forEach(panel => panel.style.display = '');
        const xMaxEl = document.getElementById('survivalXMax');
        if (xMaxEl) xMaxEl.dataset.auto = 'true';
    } else {
        if (timeInput) timeInput.disabled = false;
        if (groupSection) groupSection.style.display = '';
        if (survivalSection) survivalSection.style.display = 'none';
        if (timeSeriesSection) timeSeriesSection.style.display = mode === 'time' ? '' : 'none';
        if (longitudinalSection) longitudinalSection.style.display = 'none';
        if (previewRow) previewRow.style.display = '';
        if (longitudinalArea) longitudinalArea.style.display = 'none';
        statsPanels.forEach(panel => panel.style.display = '');
    }
    if (mode === 'time') {
        refreshAllGroupTimeGrids();
    } else {
        document.querySelectorAll('.group-card').forEach((card) => {
            const grid = card.querySelector('.group-time-grid');
            const textarea = card.querySelector('.group-data-input');
            const preview = card.querySelector('.paste-preview');
            if (grid) grid.style.display = 'none';
            if (textarea) textarea.style.display = '';
            if (preview) preview.style.display = '';
        });
    }
    const showLegendEl = document.getElementById('showLegend');
    if (showLegendEl && mode === 'comparison') {
        showLegendEl.checked = false;
    }
    if (yMaxInputEl) {
        yMaxInputEl.dataset.auto = 'true';
        yMaxInputEl.value = '0';
    }
    renderStagedGroups();
    updatePlot();
}

function parseSurvivalData(text) {
    const lines = text.trim().split('\n').map(l => l.trim()).filter(Boolean);
    const groups = new Map();
    lines.forEach(line => {
        let parts = line.split(/\t|,/).map(p => p.trim());
        if (parts.length < 3) {
            parts = line.split(/\s+/).map(p => p.trim());
        }
        if (parts.length < 2) return;
        const group = parts[0];
        let day = NaN;
        for (let i = parts.length - 1; i >= 0; i--) {
            const val = parseFloat(parts[i]);
            if (Number.isFinite(val)) {
                day = val;
                break;
            }
        }
        if (!group || !Number.isFinite(day)) return;
        if (!groups.has(group)) groups.set(group, []);
        groups.get(group).push(day);
    });
    const groupConfigs = Array.from(groups.entries()).map(([name, times], idx) => ({
        name,
        color: defaultColors[idx % defaultColors.length],
        times
    }));
    const maxTime = groupConfigs.reduce((max, g) => Math.max(max, ...g.times), 0);
    return { groupConfigs, maxTime };
}

const longitudinalPalette = ['#0b7285', '#e67700', '#2f9e44', '#d9480f', '#1c7ed6', '#862e9c', '#5f3dc4', '#c92a2a'];

function longitudinalSetStatus(msg) {
    const el = document.getElementById('longitudinalStatus');
    if (el) el.textContent = msg;
}

function longitudinalUpdateReadout() {
    const readout = document.getElementById('longitudinalCiReadout');
    if (!readout) return;
    const pct = Math.round(longitudinalState.ci * 100);
    readout.textContent = `CI = ${longitudinalState.ci.toFixed(2)} (${pct}%)`;
}

function longitudinalQuantileFromSorted(sorted, q) {
    const n = sorted.length;
    if (!n) return NaN;
    const pos = (n - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    if (sorted[base + 1] !== undefined) {
        return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
    }
    return sorted[base];
}

function longitudinalKdeMode(samples) {
    const n = samples.length;
    if (!n) return NaN;
    let mean = 0;
    for (let i = 0; i < n; i++) mean += samples[i];
    mean /= n;
    let variance = 0;
    for (let i = 0; i < n; i++) variance += (samples[i] - mean) ** 2;
    variance /= Math.max(1, n - 1);
    const std = Math.sqrt(variance) || 1e-6;
    const bandwidth = 1.06 * std * Math.pow(n, -0.2);

    let min = samples[0];
    let max = samples[0];
    for (let i = 1; i < n; i++) {
        if (samples[i] < min) min = samples[i];
        if (samples[i] > max) max = samples[i];
    }
    const padding = (max - min) * 0.1 + 1e-6;
    min -= padding;
    max += padding;
    const gridCount = 160;
    let bestX = min;
    let bestVal = -Infinity;
    for (let i = 0; i < gridCount; i++) {
        const x = min + (i / (gridCount - 1)) * (max - min);
        let sum = 0;
        for (let j = 0; j < n; j++) {
            const z = (x - samples[j]) / bandwidth;
            sum += Math.exp(-0.5 * z * z);
        }
        if (sum > bestVal) {
            bestVal = sum;
            bestX = x;
        }
    }
    return bestX;
}

function longitudinalKdeDensity(samples) {
    const n = samples.length;
    if (!n) return { x: [], y: [] };
    let mean = 0;
    for (let i = 0; i < n; i++) mean += samples[i];
    mean /= n;
    let variance = 0;
    for (let i = 0; i < n; i++) variance += (samples[i] - mean) ** 2;
    variance /= Math.max(1, n - 1);
    const std = Math.sqrt(variance) || 1e-6;
    const bandwidth = 1.06 * std * Math.pow(n, -0.2);

    let min = samples[0];
    let max = samples[0];
    for (let i = 1; i < n; i++) {
        if (samples[i] < min) min = samples[i];
        if (samples[i] > max) max = samples[i];
    }
    const padding = (max - min) * 0.1 + 1e-6;
    min -= padding;
    max += padding;

    const gridCount = 140;
    const xs = new Array(gridCount);
    const ys = new Array(gridCount);
    let maxY = 0;
    for (let i = 0; i < gridCount; i++) {
        const x = min + (i / (gridCount - 1)) * (max - min);
        let sum = 0;
        for (let j = 0; j < n; j++) {
            const z = (x - samples[j]) / bandwidth;
            sum += Math.exp(-0.5 * z * z);
        }
        xs[i] = x;
        ys[i] = sum;
        if (sum > maxY) maxY = sum;
    }
    if (maxY > 0) {
        for (let i = 0; i < ys.length; i++) ys[i] /= maxY;
    }
    return { x: xs, y: ys };
}

function longitudinalClearSvg(svg) {
    while (svg && svg.firstChild) svg.removeChild(svg.firstChild);
}

function longitudinalBuildCaches() {
    const draws = longitudinalState.draws || [];
    const nDraws = draws.length;
    const nTimes = longitudinalState.times.length;
    const nGroups = longitudinalState.groups.length;
    const A_sorted = Array.from({ length: nTimes }, () => Array(nGroups));
    const A_mode = Array.from({ length: nTimes }, () => Array(nGroups));

    for (let t = 0; t < nTimes; t++) {
        for (let g = 0; g < nGroups; g++) {
            const arr = new Float64Array(nDraws);
            for (let d = 0; d < nDraws; d++) arr[d] = draws[d][t][g];
            const sorted = Array.from(arr).sort((a, b) => a - b);
            A_sorted[t][g] = sorted;
            A_mode[t][g] = longitudinalKdeMode(arr);
        }
    }

    longitudinalState.caches = {
        A_sorted,
        A_mode,
        D_sorted: null,
        D_mode: null,
        D_density: {}
    };
}

function longitudinalBuildDiffCaches() {
    const draws = longitudinalState.draws || [];
    const nDraws = draws.length;
    const nTimes = longitudinalState.times.length;
    const nGroups = longitudinalState.groups.length;
    const controlIdx = longitudinalState.controlIdx;
    const D_sorted = Array.from({ length: nTimes }, () => Array(nGroups));
    const D_mode = Array.from({ length: nTimes }, () => Array(nGroups));
    longitudinalState.caches.D_density = {};

    for (let t = 0; t < nTimes; t++) {
        for (let g = 0; g < nGroups; g++) {
            if (g === controlIdx) {
                D_sorted[t][g] = null;
                D_mode[t][g] = null;
                continue;
            }
            const arr = new Float64Array(nDraws);
            for (let d = 0; d < nDraws; d++) {
                arr[d] = draws[d][t][g] - draws[d][t][controlIdx];
            }
            const sorted = Array.from(arr).sort((a, b) => a - b);
            D_sorted[t][g] = sorted;
            D_mode[t][g] = longitudinalKdeMode(arr);
        }
    }
    longitudinalState.caches.D_sorted = D_sorted;
    longitudinalState.caches.D_mode = D_mode;
}

function longitudinalGetDiffDensity(tIdx, gIdx) {
    const key = `${tIdx}_${gIdx}_${longitudinalState.controlIdx}`;
    if (longitudinalState.caches.D_density[key]) return longitudinalState.caches.D_density[key];
    const samples = longitudinalState.caches.D_sorted[tIdx][gIdx];
    if (!samples) return { x: [], y: [] };
    const density = longitudinalKdeDensity(samples);
    longitudinalState.caches.D_density[key] = density;
    return density;
}

function longitudinalRenderTimeCourse() {
    const svg = document.getElementById('longitudinalTimePlot');
    longitudinalClearSvg(svg);
    if (!longitudinalState.draws || longitudinalState.draws.length === 0) return;

    svg.setAttribute('viewBox', `0 0 ${longitudinalState.sizes.time.width} ${longitudinalState.sizes.time.height}`);
    svg.style.width = `${longitudinalState.sizes.time.width}px`;
    svg.style.height = `${longitudinalState.sizes.time.height}px`;
    const wrapper = document.getElementById('longitudinalTimeWrapper');
    if (wrapper) {
        wrapper.style.transform = `translate(${longitudinalState.offsets.time.x}px, ${longitudinalState.offsets.time.y}px)`;
    }

    const width = longitudinalState.sizes.time.width;
    const height = longitudinalState.sizes.time.height;
    const margin = { top: 20, right: 20, bottom: 40, left: 60 };
    const innerW = width - margin.left - margin.right;
    const innerH = height - margin.top - margin.bottom;

    const times = longitudinalState.times;
    const xMin = Math.min(...times);
    const xMax = Math.max(...times);
    const lowerQ = (1 - longitudinalState.ci) / 2;
    const upperQ = 1 - lowerQ;

    let yMin = Infinity;
    let yMax = -Infinity;
    longitudinalState.groups.forEach((_, gIdx) => {
        for (let t = 0; t < times.length; t++) {
            const sorted = longitudinalState.caches.A_sorted[t][gIdx];
            const lo = longitudinalQuantileFromSorted(sorted, lowerQ);
            const hi = longitudinalQuantileFromSorted(sorted, upperQ);
            yMin = Math.min(yMin, lo);
            yMax = Math.max(yMax, hi);
        }
    });
    const yPad = (yMax - yMin) * 0.1 + 1e-6;
    const autoMin = yMin - yPad;
    const autoMax = yMax + yPad;
    longitudinalState.axisRanges.time.autoMin = autoMin;
    longitudinalState.axisRanges.time.autoMax = autoMax;
    if (longitudinalState.axisRanges.time.auto || !isFinite(longitudinalState.axisRanges.time.min) || !isFinite(longitudinalState.axisRanges.time.max)) {
        yMin = autoMin;
        yMax = autoMax;
    } else {
        yMin = longitudinalState.axisRanges.time.min;
        yMax = longitudinalState.axisRanges.time.max;
    }

    const xScale = (x) => margin.left + ((x - xMin) / (xMax - xMin || 1)) * innerW;
    const yScale = (y) => margin.top + innerH - ((y - yMin) / (yMax - yMin || 1)) * innerH;

    const axis = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg.appendChild(axis);
    axis.innerHTML = `
        <line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + innerH}" stroke="#8c7f6c" stroke-width="${longitudinalState.axisStrokeWidth}" />
        <line x1="${margin.left}" y1="${margin.top + innerH}" x2="${margin.left + innerW}" y2="${margin.top + innerH}" stroke="#8c7f6c" stroke-width="${longitudinalState.axisStrokeWidth}" />
    `;

    for (let i = 0; i <= 5; i++) {
        const yVal = yMin + (i / 5) * (yMax - yMin);
        const y = yScale(yVal);
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', margin.left - 8);
        label.setAttribute('y', y + 4);
        label.setAttribute('text-anchor', 'end');
        label.setAttribute('font-size', '10');
        label.textContent = yVal.toFixed(2);
        svg.appendChild(label);
    }

    times.forEach((t) => {
        const x = xScale(t);
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', x);
        label.setAttribute('y', margin.top + innerH + 18);
        label.setAttribute('text-anchor', 'middle');
        label.setAttribute('font-size', '10');
        label.textContent = t;
        svg.appendChild(label);
    });

    const legend = document.getElementById('longitudinalTimeLegend');
    if (legend) legend.innerHTML = '';

    longitudinalState.groups.forEach((name, gIdx) => {
        const color = longitudinalState.colors[gIdx] || longitudinalPalette[gIdx % longitudinalPalette.length];
        const modePath = [];
        const upperPath = [];
        const lowerPath = [];
        for (let t = 0; t < times.length; t++) {
            const sorted = longitudinalState.caches.A_sorted[t][gIdx];
            const mode = longitudinalState.caches.A_mode[t][gIdx];
            const lo = longitudinalQuantileFromSorted(sorted, lowerQ);
            const hi = longitudinalQuantileFromSorted(sorted, upperQ);
            const x = xScale(times[t]);
            modePath.push(`${x},${yScale(mode)}`);
            upperPath.push(`${x},${yScale(hi)}`);
            lowerPath.push(`${x},${yScale(lo)}`);
        }
        const band = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        band.setAttribute('d', `M ${upperPath.join(' L ')} L ${lowerPath.reverse().join(' L ')} Z`);
        band.setAttribute('fill', color);
        band.setAttribute('opacity', '0.15');
        svg.appendChild(band);

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        line.setAttribute('points', modePath.join(' '));
        line.setAttribute('fill', 'none');
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-width', longitudinalState.lineWidth);
        svg.appendChild(line);

        if (legend) {
            const legendItem = document.createElement('span');
            legendItem.innerHTML = `<span style="display:inline-flex; align-items:center; gap:6px; font-size:${longitudinalState.legendFontSize}px;"><i style="display:inline-block; width:12px; height:4px; background:${color}; border-radius:2px;"></i>${name}</span>`;
            legend.appendChild(legendItem);
        }
    });

    const yMinInput = document.getElementById('longitudinalTimeYMin');
    const yMaxInput = document.getElementById('longitudinalTimeYMax');
    const yMinSlider = document.getElementById('longitudinalTimeYMinSlider');
    const yMaxSlider = document.getElementById('longitudinalTimeYMaxSlider');
    if (yMinInput && yMaxInput && yMinSlider && yMaxSlider) {
        yMinSlider.min = autoMin;
        yMinSlider.max = autoMax;
        yMaxSlider.min = autoMin;
        yMaxSlider.max = autoMax;
        yMinSlider.value = yMin;
        yMaxSlider.value = yMax;
        if (longitudinalState.axisRanges.time.auto) {
            yMinInput.value = '';
            yMaxInput.value = '';
        } else {
            yMinInput.value = yMin.toFixed(3);
            yMaxInput.value = yMax.toFixed(3);
        }
    }
}

function longitudinalRenderDifference() {
    const svg = document.getElementById('longitudinalDiffPlot');
    longitudinalClearSvg(svg);
    if (!longitudinalState.draws || longitudinalState.draws.length === 0) return;

    svg.setAttribute('viewBox', `0 0 ${longitudinalState.sizes.diff.width} ${longitudinalState.sizes.diff.height}`);
    svg.style.width = `${longitudinalState.sizes.diff.width}px`;
    svg.style.height = `${longitudinalState.sizes.diff.height}px`;
    const wrapper = document.getElementById('longitudinalDiffWrapper');
    if (wrapper) {
        wrapper.style.transform = `translate(${longitudinalState.offsets.diff.x}px, ${longitudinalState.offsets.diff.y}px)`;
    }

    const width = longitudinalState.sizes.diff.width;
    const height = longitudinalState.sizes.diff.height;
    const margin = { top: 20, right: 20, bottom: 40, left: 60 };
    const innerW = width - margin.left - margin.right;
    const innerH = height - margin.top - margin.bottom;

    const timeContainer = document.getElementById('longitudinalTimeChecklist');
    const groupContainer = document.getElementById('longitudinalGroupChecklist');
    const selectedTimes = Array.from(timeContainer.querySelectorAll('input[type=checkbox]:checked'))
        .map(el => parseInt(el.dataset.index, 10));
    const selectedGroups = Array.from(groupContainer.querySelectorAll('input[type=checkbox]:checked'))
        .map(el => parseInt(el.dataset.index, 10));

    const densities = [];
    let xMin = Infinity;
    let xMax = -Infinity;

    selectedTimes.forEach((tIdx) => {
        selectedGroups.forEach((gIdx) => {
            if (gIdx === longitudinalState.controlIdx) return;
            const density = longitudinalGetDiffDensity(tIdx, gIdx);
            if (!density.x.length) return;
            densities.push({ tIdx, gIdx, density });
            xMin = Math.min(xMin, density.x[0]);
            xMax = Math.max(xMax, density.x[density.x.length - 1]);
        });
    });
    if (!isFinite(xMin) || !isFinite(xMax)) return;
    const xPad = (xMax - xMin) * 0.1 + 1e-6;
    const autoMin = xMin - xPad;
    const autoMax = xMax + xPad;
    longitudinalState.axisRanges.diff.autoMin = autoMin;
    longitudinalState.axisRanges.diff.autoMax = autoMax;
    if (longitudinalState.axisRanges.diff.auto || !isFinite(longitudinalState.axisRanges.diff.min) || !isFinite(longitudinalState.axisRanges.diff.max)) {
        xMin = autoMin;
        xMax = autoMax;
    } else {
        xMin = longitudinalState.axisRanges.diff.min;
        xMax = longitudinalState.axisRanges.diff.max;
    }

    const xScale = (x) => margin.left + ((x - xMin) / (xMax - xMin || 1)) * innerW;
    const yScale = (y) => margin.top + innerH - y * innerH;

    const axis = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg.appendChild(axis);
    axis.innerHTML = `
        <line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + innerH}" stroke="#8c7f6c" stroke-width="${longitudinalState.axisStrokeWidth}" />
        <line x1="${margin.left}" y1="${margin.top + innerH}" x2="${margin.left + innerW}" y2="${margin.top + innerH}" stroke="#8c7f6c" stroke-width="${longitudinalState.axisStrokeWidth}" />
    `;

    for (let i = 0; i <= 5; i++) {
        const xVal = xMin + (i / 5) * (xMax - xMin);
        const x = xScale(xVal);
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', x);
        label.setAttribute('y', margin.top + innerH + 18);
        label.setAttribute('text-anchor', 'middle');
        label.setAttribute('font-size', '10');
        label.textContent = xVal.toFixed(2);
        svg.appendChild(label);
    }

    const legend = document.getElementById('longitudinalDiffLegend');
    if (legend) legend.innerHTML = '';

    const lowerQ = (1 - longitudinalState.ci) / 2;
    const upperQ = 1 - lowerQ;

    densities.forEach((item, idx) => {
        const color = longitudinalState.colors[item.gIdx] || longitudinalPalette[idx % longitudinalPalette.length];
        const { tIdx, gIdx, density } = item;
        const points = density.x.map((x, i) => `${xScale(x)},${yScale(density.y[i])}`).join(' ');
        const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        polyline.setAttribute('points', points);
        polyline.setAttribute('fill', 'none');
        polyline.setAttribute('stroke', color);
        polyline.setAttribute('stroke-width', longitudinalState.lineWidth);
        svg.appendChild(polyline);

        const sorted = longitudinalState.caches.D_sorted[tIdx][gIdx];
        const mode = longitudinalState.caches.D_mode[tIdx][gIdx];
        const lo = longitudinalQuantileFromSorted(sorted, lowerQ);
        const hi = longitudinalQuantileFromSorted(sorted, upperQ);

        const modeLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        modeLine.setAttribute('x1', xScale(mode));
        modeLine.setAttribute('x2', xScale(mode));
        modeLine.setAttribute('y1', margin.top);
        modeLine.setAttribute('y2', margin.top + innerH);
        modeLine.setAttribute('stroke', color);
        modeLine.setAttribute('stroke-dasharray', '4,4');
        svg.appendChild(modeLine);

        [lo, hi].forEach((val) => {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', xScale(val));
            line.setAttribute('x2', xScale(val));
            line.setAttribute('y1', margin.top);
            line.setAttribute('y2', margin.top + innerH);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', longitudinalState.ciLineWidth);
            svg.appendChild(line);
        });

        if (legend) {
            const legendItem = document.createElement('span');
            legendItem.innerHTML = `<span style="display:inline-flex; align-items:center; gap:6px; font-size:${longitudinalState.legendFontSize}px;"><i style="display:inline-block; width:12px; height:4px; background:${color}; border-radius:2px;"></i>${longitudinalState.groups[gIdx]} @ t=${longitudinalState.times[tIdx]}</span>`;
            legend.appendChild(legendItem);
        }
    });

    const xMinInput = document.getElementById('longitudinalDiffXMin');
    const xMaxInput = document.getElementById('longitudinalDiffXMax');
    const xMinSlider = document.getElementById('longitudinalDiffXMinSlider');
    const xMaxSlider = document.getElementById('longitudinalDiffXMaxSlider');
    if (xMinInput && xMaxInput && xMinSlider && xMaxSlider) {
        xMinSlider.min = autoMin;
        xMinSlider.max = autoMax;
        xMaxSlider.min = autoMin;
        xMaxSlider.max = autoMax;
        xMinSlider.value = xMin;
        xMaxSlider.value = xMax;
        if (longitudinalState.axisRanges.diff.auto) {
            xMinInput.value = '';
            xMaxInput.value = '';
        } else {
            xMinInput.value = xMin.toFixed(3);
            xMaxInput.value = xMax.toFixed(3);
        }
    }
}

function updateLongitudinalPlots() {
    longitudinalBuildColorControls();
    longitudinalRenderTimeCourse();
    longitudinalRenderDifference();
}

function longitudinalBuildChecklist(container, items, indexValues) {
    container.innerHTML = '';
    items.forEach((label, idx) => {
        const box = document.createElement('input');
        box.type = 'checkbox';
        box.checked = true;
        box.dataset.index = indexValues[idx];
        const wrapper = document.createElement('label');
        wrapper.style.fontWeight = 'normal';
        wrapper.appendChild(box);
        wrapper.appendChild(document.createTextNode(` ${label}`));
        container.appendChild(wrapper);
    });
}

function longitudinalSetupControls() {
    const controlSelect = document.getElementById('longitudinalControlSelect');
    const timeList = document.getElementById('longitudinalTimeChecklist');
    const groupList = document.getElementById('longitudinalGroupChecklist');
    if (!controlSelect || !timeList || !groupList) return;

    controlSelect.innerHTML = '';
    longitudinalState.groups.forEach((g, idx) => {
        const option = document.createElement('option');
        option.value = idx;
        option.textContent = g;
        controlSelect.appendChild(option);
    });
    controlSelect.value = longitudinalState.controlIdx;

    longitudinalBuildChecklist(timeList, longitudinalState.times.map(String), longitudinalState.times.map((_, i) => i));
    const groupLabels = [];
    const groupIndexes = [];
    longitudinalState.groups.forEach((g, idx) => {
        if (idx === longitudinalState.controlIdx) return;
        groupLabels.push(g);
        groupIndexes.push(idx);
    });
    longitudinalBuildChecklist(groupList, groupLabels, groupIndexes);

    controlSelect.onchange = () => {
        longitudinalState.controlIdx = parseInt(controlSelect.value, 10);
        longitudinalSetupControls();
        longitudinalBuildDiffCaches();
        updateLongitudinalPlots();
    };
    timeList.onchange = updateLongitudinalPlots;
    groupList.onchange = updateLongitudinalPlots;
}

function longitudinalSetData(draws, groups, times, sourceLabel) {
    longitudinalState.draws = draws;
    longitudinalState.groups = groups;
    longitudinalState.times = times.map(t => parseInt(t, 10));
    longitudinalState.controlIdx = 0;
    longitudinalState.source = sourceLabel;
    longitudinalState.colors = groups.map((_, idx) => longitudinalPalette[idx % longitudinalPalette.length]);
    longitudinalBuildCaches();
    longitudinalBuildDiffCaches();
    longitudinalSetupControls();
    longitudinalBuildColorControls();
    longitudinalSyncSizeInputs();
    longitudinalUpdateReadout();
    longitudinalSetStatus(`Loaded ${draws.length} draws (${sourceLabel}).`);
    updateLongitudinalPlots();
}

function longitudinalParseCsv(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    if (!lines.length) return [];
    const header = lines[0].split(/,|\t/).map(h => h.trim());
    const rows = [];
    for (let i = 1; i < lines.length; i++) {
        const parts = lines[i].split(/,|\t/);
        if (parts.length < header.length) continue;
        const row = {};
        header.forEach((h, idx) => row[h] = (parts[idx] || '').trim());
        rows.push(row);
    }
    return rows;
}

function longitudinalBuildEmpiricalDraws(rows, idCol, groupCol, timeCol, yCol) {
    const groups = Array.from(new Set(rows.map(r => r[groupCol]))).filter(Boolean);
    const times = Array.from(new Set(rows.map(r => parseInt(r[timeCol], 10)))).filter(n => Number.isFinite(n)).sort((a, b) => a - b);
    const byGroupTime = new Map();
    const byGroup = new Map();
    rows.forEach((row) => {
        const g = row[groupCol];
        const t = parseInt(row[timeCol], 10);
        const y = parseFloat(row[yCol]);
        if (!g || !Number.isFinite(t) || !Number.isFinite(y)) return;
        if (y <= 0) throw new Error('y must be positive for LogNormal.');
        const logy = Math.log(y);
        const key = `${g}::${t}`;
        if (!byGroupTime.has(key)) byGroupTime.set(key, []);
        byGroupTime.get(key).push(logy);
        if (!byGroup.has(g)) byGroup.set(g, []);
        byGroup.get(g).push(logy);
    });
    const global = rows.map(r => Math.log(parseFloat(r[yCol]))).filter(v => Number.isFinite(v));

    const nDraws = 400;
    const draws = [];
    function randn() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
    for (let d = 0; d < nDraws; d++) {
        const draw = [];
        times.forEach((t) => {
            const row = [];
            groups.forEach((g) => {
                const key = `${g}::${t}`;
                let arr = byGroupTime.get(key);
                if (!arr || arr.length === 0) arr = byGroup.get(g);
                if (!arr || arr.length === 0) arr = global;
                if (!arr || arr.length === 0) arr = [0];
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const varSum = arr.reduce((a, b) => a + (b - mean) ** 2, 0);
                const std = Math.sqrt(varSum / Math.max(1, arr.length - 1)) || 0.1;
                const sample = Math.exp(mean + std * randn());
                row.push(sample);
            });
            draw.push(row);
        });
        draws.push(draw);
    }
    return { draws, groups, times };
}

function loadLongitudinalRawText(text) {
    const idCol = document.getElementById('longitudinalIdCol').value.trim() || 'id';
    const groupCol = document.getElementById('longitudinalGroupCol').value.trim() || 'group';
    const timeCol = document.getElementById('longitudinalTimeCol').value.trim() || 'time';
    const yCol = document.getElementById('longitudinalYCol').value.trim() || 'y';
    longitudinalState.raw = text;
    const rows = longitudinalParseCsv(text);
    if (!rows.length) {
        longitudinalSetStatus('No rows found in CSV.');
        return;
    }
    if (!rows[0].hasOwnProperty(groupCol) || !rows[0].hasOwnProperty(timeCol) || !rows[0].hasOwnProperty(yCol)) {
        longitudinalSetStatus('Missing required columns in CSV.');
        return;
    }
    try {
        const result = longitudinalBuildEmpiricalDraws(rows, idCol, groupCol, timeCol, yCol);
        longitudinalSetData(result.draws, result.groups, result.times, 'empirical preview');
        longitudinalSetStatus('Raw data loaded. For full Bayesian model, run fit_model.py to generate posterior draws.');
    } catch (err) {
        longitudinalSetStatus(err.message);
    }
}

function loadLongitudinalPosteriorJson(data) {
    if (!data || !data.draws || !data.groups || !data.times) {
        longitudinalSetStatus('Invalid JSON. Required keys: draws, groups, times.');
        return;
    }
    longitudinalSetData(data.draws, data.groups, data.times, 'posterior');
}

function loadSampleLongitudinalData() {
    const sample = (() => {
        const groups = ['control', 'treatA', 'treatB'];
        const times = [0, 1, 2, 3];
        const draws = [];
        let seed = 1234;
        const rng = () => {
            seed = (seed * 1664525 + 1013904223) % 4294967296;
            return seed / 4294967296;
        };
        for (let d = 0; d < 250; d++) {
            const draw = [];
            const base = 1.0 + rng() * 0.2;
            times.forEach((t) => {
                const row = [];
                groups.forEach((g) => {
                    const drift = g === 'treatA' ? 0.18 : (g === 'treatB' ? 0.08 : 0.12);
                    const val = base * (1 + drift * t) * (0.9 + rng() * 0.2);
                    row.push(val);
                });
                draw.push(row);
            });
            draws.push(draw);
        }
        return { draws, groups, times };
    })();
    longitudinalSetData(sample.draws, sample.groups, sample.times, 'example');
}

function sanitizeFileName(name) {
    const cleaned = String(name || '').replace(/[<>:"/\\|?*\x00-\x1F]/g, '_').trim();
    return cleaned || 'figure';
}

function getExportTypeMeta(format) {
    const key = String(format || 'svg').toLowerCase();
    if (key === 'png') {
        return {
            key: 'png',
            ext: 'png',
            mime: 'image/png',
            typeOption: { description: 'PNG image', accept: { 'image/png': ['.png'] } }
        };
    }
    if (key === 'pdf') {
        return {
            key: 'pdf',
            ext: 'pdf',
            mime: 'application/pdf',
            typeOption: { description: 'PDF document', accept: { 'application/pdf': ['.pdf'] } }
        };
    }
    if (key === 'tif' || key === 'tiff') {
        return {
            key: 'tif',
            ext: 'tif',
            mime: 'image/tiff',
            typeOption: { description: 'TIFF image', accept: { 'image/tiff': ['.tif', '.tiff'] } }
        };
    }
    return {
        key: 'svg',
        ext: 'svg',
        mime: 'image/svg+xml',
        typeOption: { description: 'SVG image', accept: { 'image/svg+xml': ['.svg'] } }
    };
}

function ensureFileExtension(filename, ext) {
    const safe = sanitizeFileName(filename);
    const lower = safe.toLowerCase();
    const suffix = `.${ext.toLowerCase()}`;
    return lower.endsWith(suffix) ? safe : `${safe}.${ext}`;
}

function getExportBaseName(fallbackName = 'figure') {
    const input = document.getElementById('exportFileName');
    const fromInput = input ? sanitizeFileName(input.value) : '';
    if (fromInput) return fromInput;
    return sanitizeFileName(fallbackName);
}

function updateExportPathLabel() {
    const label = document.getElementById('exportPathLabel');
    if (!label) return;
    label.textContent = exportDirectoryName ? `Path: ${exportDirectoryName}` : 'Path: Browser download';
}

async function chooseExportDirectory() {
    if (!window.showDirectoryPicker) {
        showToast('Folder picker unsupported. Using save dialog.');
        return;
    }
    try {
        const handle = await window.showDirectoryPicker();
        exportDirectoryHandle = handle;
        exportDirectoryName = handle && handle.name ? handle.name : 'Selected folder';
        updateExportPathLabel();
        showToast('Folder selected');
    } catch (err) {
        if (err && err.name !== 'AbortError') {
            showToast('Failed to select folder');
        }
    }
}

function serializeSvgForExport(svg, forceTransparent = true) {
    let source = new XMLSerializer().serializeToString(svg);
    if (!forceTransparent) return source;
    source = source.replace(/<rect class="svg-bg"[^>]*\/?>/gi, '');
    source = source.replace(/<rect class="svg-bg"[^>]*>[\s\S]*?<\/rect>/gi, '');
    source = source.replace(/background\s*:\s*[^;"]*;?/gi, '');
    source = source.replace(/style="\s*"/gi, '');
    return source;
}

function applySvgRenderSize(source, width, height) {
    return source.replace(/<svg\b([^>]*)>/i, (full, attrs) => {
        let clean = attrs
            .replace(/\swidth="[^"]*"/i, '')
            .replace(/\sheight="[^"]*"/i, '');
        return `<svg${clean} width="${Math.max(1, Math.round(width))}" height="${Math.max(1, Math.round(height))}">`;
    });
}

function canvasToBlobAsync(canvas, mimeType, quality) {
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error('Failed to create image blob.'));
            }
        }, mimeType, quality);
    });
}

function getSvgSize(svg) {
    const viewBox = svg.getAttribute('viewBox');
    if (viewBox) {
        const parts = viewBox.trim().split(/\s+/).map(v => parseFloat(v));
        if (parts.length === 4 && isFinite(parts[2]) && isFinite(parts[3]) && parts[2] > 0 && parts[3] > 0) {
            return { width: Math.round(parts[2]), height: Math.round(parts[3]) };
        }
    }
    const wAttr = parseFloat(svg.getAttribute('width'));
    const hAttr = parseFloat(svg.getAttribute('height'));
    if (isFinite(wAttr) && wAttr > 0 && isFinite(hAttr) && hAttr > 0) {
        return { width: Math.round(wAttr), height: Math.round(hAttr) };
    }
    const rect = svg.getBoundingClientRect();
    return {
        width: Math.max(1, Math.round(rect.width || 900)),
        height: Math.max(1, Math.round(rect.height || 360))
    };
}

function getHighQualityExportScale(size) {
    const targetLongEdge = 8192;
    const maxScale = 12;
    const longEdge = Math.max(1, size.width, size.height);
    const scaled = Math.ceil(targetLongEdge / longEdge);
    return Math.max(1, Math.min(maxScale, scaled));
}

async function renderSvgToCanvas(svg) {
    const logicalSize = getSvgSize(svg);
    const scale = getHighQualityExportScale(logicalSize);
    const renderWidth = logicalSize.width * scale;
    const renderHeight = logicalSize.height * scale;
    let source = serializeSvgForExport(svg, true);
    source = applySvgRenderSize(source, renderWidth, renderHeight);
    const url = URL.createObjectURL(new Blob([source], { type: 'image/svg+xml;charset=utf-8' }));
    try {
        const img = new Image();
        await new Promise((resolve, reject) => {
            img.onload = () => resolve();
            img.onerror = () => reject(new Error('Failed to render SVG image.'));
            img.src = url;
        });
        const canvas = document.createElement('canvas');
        canvas.width = renderWidth;
        canvas.height = renderHeight;
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            throw new Error('Canvas context is unavailable.');
        }
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        return { canvas, logicalSize, scale };
    } finally {
        URL.revokeObjectURL(url);
    }
}

function encodeTiffFromCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        throw new Error('Canvas context is unavailable.');
    }
    const width = canvas.width;
    const height = canvas.height;
    const pixelData = ctx.getImageData(0, 0, width, height).data;

    const entryCount = 14;
    const ifdOffset = 8;
    const ifdByteSize = 2 + (entryCount * 12) + 4;
    const bitsOffset = ifdOffset + ifdByteSize;
    const xResOffset = bitsOffset + 8;
    const yResOffset = xResOffset + 8;
    const pixelOffset = yResOffset + 8;
    const totalBytes = pixelOffset + pixelData.length;

    const buffer = new ArrayBuffer(totalBytes);
    const view = new DataView(buffer);
    const out = new Uint8Array(buffer);

    view.setUint8(0, 0x49);
    view.setUint8(1, 0x49);
    view.setUint16(2, 42, true);
    view.setUint32(4, ifdOffset, true);
    view.setUint16(ifdOffset, entryCount, true);

    let ptr = ifdOffset + 2;
    const TYPE_SHORT = 3;
    const TYPE_LONG = 4;
    const TYPE_RATIONAL = 5;

    function writeEntry(tag, type, count, value) {
        view.setUint16(ptr, tag, true);
        view.setUint16(ptr + 2, type, true);
        view.setUint32(ptr + 4, count, true);
        if (type === TYPE_SHORT && count === 1) {
            view.setUint16(ptr + 8, value, true);
            view.setUint16(ptr + 10, 0, true);
        } else {
            view.setUint32(ptr + 8, value, true);
        }
        ptr += 12;
    }

    writeEntry(256, TYPE_LONG, 1, width);
    writeEntry(257, TYPE_LONG, 1, height);
    writeEntry(258, TYPE_SHORT, 4, bitsOffset);
    writeEntry(259, TYPE_SHORT, 1, 1);
    writeEntry(262, TYPE_SHORT, 1, 2);
    writeEntry(273, TYPE_LONG, 1, pixelOffset);
    writeEntry(277, TYPE_SHORT, 1, 4);
    writeEntry(278, TYPE_LONG, 1, height);
    writeEntry(279, TYPE_LONG, 1, pixelData.length);
    writeEntry(282, TYPE_RATIONAL, 1, xResOffset);
    writeEntry(283, TYPE_RATIONAL, 1, yResOffset);
    writeEntry(284, TYPE_SHORT, 1, 1);
    writeEntry(338, TYPE_SHORT, 1, 2);
    writeEntry(296, TYPE_SHORT, 1, 2);
    view.setUint32(ptr, 0, true);

    view.setUint16(bitsOffset, 8, true);
    view.setUint16(bitsOffset + 2, 8, true);
    view.setUint16(bitsOffset + 4, 8, true);
    view.setUint16(bitsOffset + 6, 8, true);
    view.setUint32(xResOffset, 1200, true);
    view.setUint32(xResOffset + 4, 1, true);
    view.setUint32(yResOffset, 1200, true);
    view.setUint32(yResOffset + 4, 1, true);
    out.set(pixelData, pixelOffset);

    return new Blob([buffer], { type: 'image/tiff' });
}

function asciiBytes(text) {
    return new TextEncoder().encode(text);
}

async function buildPdfBlobFromCanvas(canvas, logicalSize = null) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Canvas context is unavailable.');
    const rgba = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    const rgbBytes = new Uint8Array(canvas.width * canvas.height * 3);
    const alphaBytes = new Uint8Array(canvas.width * canvas.height);
    for (let i = 0, j = 0, k = 0; i < rgba.length; i += 4, j += 3, k += 1) {
        rgbBytes[j] = rgba[i];
        rgbBytes[j + 1] = rgba[i + 1];
        rgbBytes[j + 2] = rgba[i + 2];
        alphaBytes[k] = rgba[i + 3];
    }

    const widthPx = canvas.width;
    const heightPx = canvas.height;
    const logicalWidth = logicalSize && isFinite(logicalSize.width) ? logicalSize.width : widthPx;
    const logicalHeight = logicalSize && isFinite(logicalSize.height) ? logicalSize.height : heightPx;
    const widthPt = ((logicalWidth * 72) / 96).toFixed(2);
    const heightPt = ((logicalHeight * 72) / 96).toFixed(2);
    const content = `q\n${widthPt} 0 0 ${heightPt} 0 0 cm\n/Im0 Do\nQ\n`;

    const obj1 = asciiBytes('1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n');
    const obj2 = asciiBytes('2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n');
    const obj3 = asciiBytes(`3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${widthPt} ${heightPt}] /Resources << /XObject << /Im0 4 0 R >> >> /Contents 6 0 R >>\nendobj\n`);
    const obj4Prefix = asciiBytes(`4 0 obj\n<< /Type /XObject /Subtype /Image /Width ${widthPx} /Height ${heightPx} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Length ${rgbBytes.length} /SMask 5 0 R >>\nstream\n`);
    const obj4Suffix = asciiBytes('\nendstream\nendobj\n');
    const obj5Prefix = asciiBytes(`5 0 obj\n<< /Type /XObject /Subtype /Image /Width ${widthPx} /Height ${heightPx} /ColorSpace /DeviceGray /BitsPerComponent 8 /Length ${alphaBytes.length} >>\nstream\n`);
    const obj5Suffix = asciiBytes('\nendstream\nendobj\n');
    const obj6 = asciiBytes(`6 0 obj\n<< /Length ${content.length} >>\nstream\n${content}endstream\nendobj\n`);

    const header = new Uint8Array([...asciiBytes('%PDF-1.3\n'), 37, 255, 255, 255, 255, 10]);
    const objectChunks = [
        obj1,
        obj2,
        obj3,
        obj4Prefix,
        rgbBytes,
        obj4Suffix,
        obj5Prefix,
        alphaBytes,
        obj5Suffix,
        obj6
    ];

    const objectOffsets = [0];
    let cursor = header.length;
    objectOffsets.push(cursor);
    cursor += obj1.length;
    objectOffsets.push(cursor);
    cursor += obj2.length;
    objectOffsets.push(cursor);
    cursor += obj3.length;
    objectOffsets.push(cursor);
    cursor += obj4Prefix.length + rgbBytes.length + obj4Suffix.length;
    objectOffsets.push(cursor);
    cursor += obj5Prefix.length + alphaBytes.length + obj5Suffix.length;
    objectOffsets.push(cursor);
    cursor += obj6.length;

    const xrefOffset = cursor;
    let xref = 'xref\n0 7\n0000000000 65535 f \n';
    for (let i = 1; i <= 6; i++) {
        xref += `${String(objectOffsets[i]).padStart(10, '0')} 00000 n \n`;
    }
    const trailer = `trailer\n<< /Size 7 /Root 1 0 R >>\nstartxref\n${xrefOffset}\n%%EOF`;
    return new Blob([header, ...objectChunks, asciiBytes(xref), asciiBytes(trailer)], { type: 'application/pdf' });
}

async function buildExportBlob(svg, format) {
    const meta = getExportTypeMeta(format);
    if (meta.key === 'svg') {
        const source = serializeSvgForExport(svg, true);
        return { blob: new Blob([source], { type: 'image/svg+xml;charset=utf-8' }), meta };
    }
    const rendered = await renderSvgToCanvas(svg);
    if (meta.key === 'png') {
        const blob = await canvasToBlobAsync(rendered.canvas, 'image/png');
        return { blob, meta };
    }
    if (meta.key === 'pdf') {
        const blob = await buildPdfBlobFromCanvas(rendered.canvas, rendered.logicalSize);
        return { blob, meta };
    }
    const blob = encodeTiffFromCanvas(rendered.canvas);
    return { blob, meta };
}

async function saveBlobAs(blob, filename, meta) {
    const suggestedName = ensureFileExtension(filename, meta.ext);

    if (exportDirectoryHandle && typeof exportDirectoryHandle.getFileHandle === 'function') {
        try {
            const fileHandle = await exportDirectoryHandle.getFileHandle(suggestedName, { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(blob);
            await writable.close();
            showToast(`Saved: ${suggestedName}`);
            return;
        } catch (err) {
            exportDirectoryHandle = null;
            exportDirectoryName = '';
            updateExportPathLabel();
        }
    }

    if (window.showSaveFilePicker) {
        try {
            const handle = await window.showSaveFilePicker({
                suggestedName,
                types: [meta.typeOption]
            });
            const writable = await handle.createWritable();
            await writable.write(blob);
            await writable.close();
            showToast(`Saved: ${suggestedName}`);
            return;
        } catch (err) {
            if (err && err.name === 'AbortError') return;
        }
    }

    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = suggestedName;
    link.click();
    URL.revokeObjectURL(url);
    showToast(`Downloaded: ${suggestedName}`);
}

async function exportSvgElement(svg, format, filenameBase) {
    if (!svg) {
        showToast('No chart to export.');
        return;
    }
    const base = sanitizeFileName(filenameBase || 'figure');
    const result = await buildExportBlob(svg, format);
    await saveBlobAs(result.blob, base, result.meta);
}

async function exportSvgById(svgId, format, filenameBase) {
    const svg = document.getElementById(svgId);
    if (!svg) {
        showToast('No chart to export.');
        return;
    }
    await exportSvgElement(svg, format, filenameBase);
}

async function saveCurrentFigure() {
    try {
        const svg = document.querySelector('#svg-container svg');
        if (!svg) {
            showToast('No chart to export.');
            return;
        }
        const format = document.getElementById('exportFormat')?.value || 'svg';
        const base = getExportBaseName('MultiGroup_Figure');
        await exportSvgElement(svg, format, base);
    } catch (err) {
        alert(`Export failed: ${err.message || err}`);
    }
}

async function longitudinalDownloadSvg(svgId, filename) {
    const name = sanitizeFileName(String(filename || '').replace(/\.svg$/i, ''));
    await exportSvgById(svgId, 'svg', name);
}

async function longitudinalDownloadPng(svgId, filename) {
    const name = sanitizeFileName(String(filename || '').replace(/\.png$/i, ''));
    await exportSvgById(svgId, 'png', name);
}

function longitudinalBuildColorControls() {
    const list = document.getElementById('longitudinalColorList');
    if (!list) return;
    list.innerHTML = '';
    longitudinalState.groups.forEach((name, idx) => {
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '8px';
        const swatch = document.createElement('input');
        swatch.type = 'color';
        swatch.value = longitudinalState.colors[idx] || longitudinalPalette[idx % longitudinalPalette.length];
        swatch.addEventListener('input', () => {
            longitudinalState.colors[idx] = swatch.value;
            updateLongitudinalPlots();
        });
        const label = document.createElement('span');
        label.textContent = name;
        label.style.fontSize = '0.75rem';
        row.appendChild(swatch);
        row.appendChild(label);
        list.appendChild(row);
    });
}

function longitudinalSyncSizeInputs() {
    const timeW = document.getElementById('longitudinalTimeWidth');
    const timeH = document.getElementById('longitudinalTimeHeight');
    const diffW = document.getElementById('longitudinalDiffWidth');
    const diffH = document.getElementById('longitudinalDiffHeight');
    if (timeW) timeW.value = longitudinalState.sizes.time.width;
    if (timeH) timeH.value = longitudinalState.sizes.time.height;
    if (diffW) diffW.value = longitudinalState.sizes.diff.width;
    if (diffH) diffH.value = longitudinalState.sizes.diff.height;
}

function computeSurvivalCurve(times) {
    const sorted = times.slice().sort((a, b) => a - b);
    let atRisk = sorted.length;
    let surv = 1;
    const steps = [{ t: 0, s: 1 }];
    let i = 0;
    while (i < sorted.length) {
        const t = sorted[i];
        let d = 0;
        while (i < sorted.length && sorted[i] === t) {
            d += 1;
            i += 1;
        }
        if (atRisk > 0) {
            surv = surv * (atRisk - d) / atRisk;
        }
        atRisk -= d;
        steps.push({ t, s: surv });
    }
    return steps;
}

function logRankTestTwoGroups(timesA, timesB) {
    const allTimes = Array.from(new Set([...timesA, ...timesB])).sort((a, b) => a - b);
    let o1 = 0;
    let e1 = 0;
    let v1 = 0;

    allTimes.forEach(t => {
        const n1 = timesA.filter(x => x >= t).length;
        const n2 = timesB.filter(x => x >= t).length;
        const d1 = timesA.filter(x => x === t).length;
        const d2 = timesB.filter(x => x === t).length;
        const n = n1 + n2;
        const d = d1 + d2;
        if (n <= 1 || d === 0) return;
        const expected1 = d * (n1 / n);
        const variance = (n1 * n2 * d * (n - d)) / (n * n * (n - 1));
        o1 += d1;
        e1 += expected1;
        v1 += variance;
    });

    if (v1 <= 0) return null;
    const z = (o1 - e1) / Math.sqrt(v1);
    const p = 2 * (1 - normalCDF(Math.abs(z)));
    return { z, p };
}

function displayStats(timeLabels, groupConfigs) {
    const nGroups = groupConfigs.length;
    const mainHeader = nGroups === 2 ? "Welch's t (p)" : "ANOVA (p)";
    const formatP = (p) => {
        if (p === null || p === undefined || Number.isNaN(p)) return "-";
        if (p < 0.0001) return "<0.0001";
        return p.toFixed(4);
    };
    const formatPPrecise = (p) => {
        if (p === null || p === undefined || Number.isNaN(p)) return "-";
        if (p === 0) return "0";
        return p.toExponential(20);
    };
    const formatPPreciseWithDecimal = (p) => {
        if (p === null || p === undefined || Number.isNaN(p)) return "-";
        if (p === 0) return "0";
        const exp = p.toExponential(20);
        const dec = p.toFixed(22).replace(/\.?0+$/, "");
        return `${exp} (${dec})`;
    };
    const detailLines = [];

    let html = `<table style="width:100%; border-collapse: collapse; font-size: 0.85rem;">
        <thead>
            <tr style="background:#f1f3f5; border-bottom:2px solid #dee2e6;">
                <th style="padding:10px;">Time Point</th>
                <th style="padding:10px;">${mainHeader}</th>
                <th style="padding:10px;">${nGroups === 2 ? 'Brunner-Munzel (p)' : 'Dunnett (Post-hoc)'}</th>
                <th style="padding:10px;">Significance</th>
            </tr>
        </thead>
        <tbody>`;

    timeLabels.forEach((label, tIdx) => {
        const filteredGroups = groupConfigs.filter(g => (g.data[tIdx] || []).length > 1);
        const groupsData = filteredGroups.map(g => g.data[tIdx]);
        if (groupsData.length < 2) return;

        let pMain = 1;
        let postHocHtml = "-";
        let status = "NS";
        const detailParts = [];

        if (nGroups === 2) {
            const res = welchTTest(groupsData[0], groupsData[1]);
            const bm = brunnerMunzel(groupsData[0], groupsData[1]);
            pMain = res ? res.p : 1;
            postHocHtml = bm ? formatP(bm.p) : "-";
            status = pMain < 0.05 ? "Significant" : "NS";
            if (res) {
                detailParts.push(`Welch t=${res.t.toFixed(3)}, df=${res.df.toFixed(2)}, p=${formatPPreciseWithDecimal(res.p)}`);
            }
            if (bm && Number.isFinite(bm.w) && Number.isFinite(bm.p) && bm.p > 0) {
                detailParts.push(`Brunner-Munzel (approx) W=${bm.w.toFixed(3)}, df=${bm.df ? bm.df.toFixed(2) : "-"}, p=${formatPPreciseWithDecimal(bm.p)}`);
            } else {
                detailParts.push('Brunner-Munzel (approx) result invalid or unstable (use external tool).');
            }
        } else {
            const aRes = oneWayANOVA(groupsData);
            if (aRes) {
                pMain = fDistributionP(aRes.f, aRes.df1, aRes.df2);
                const dunnettRes = runDunnett(groupsData, aRes.msWithin, aRes.df2);
                postHocHtml = dunnettRes.map((r, idx) =>
                    `<div style="color:${r.isSig ? 'var(--danger)' : 'var(--muted)'}">${filteredGroups[idx + 1].name}: p=${formatP(r.p)}</div>`
                ).join("");
                status = pMain < 0.05 ? "Significant" : "NS";
                detailParts.push(`ANOVA F=${aRes.f.toFixed(3)}, df1=${aRes.df1}, df2=${aRes.df2}, p=${formatPPreciseWithDecimal(pMain)}`);
                dunnettRes.forEach((r, idx) => {
                    detailParts.push(`Dunnett vs Ctrl -> ${filteredGroups[idx + 1].name}: p=${formatPPreciseWithDecimal(r.p)}`);
                });
            }
        }

        html += `<tr style="border-bottom:1px solid var(--border);">
            <td style="padding:8px; font-weight:bold;">${label}</td>
            <td style="padding:8px; color:${pMain < 0.05 ? 'red' : 'black'}">${formatP(pMain)}</td>
            <td style="padding:8px; font-size:0.75rem;">${postHocHtml}</td>
            <td style="padding:8px;"><strong>${status}</strong></td>
        </tr>`;
        if (detailParts.length) {
            detailLines.push(`[${label}]\n${detailParts.join('\n')}`);
        }
    });

    html += `</tbody></table>`;
    document.getElementById('statsTableContainer').innerHTML = html;
    const detailEl = document.getElementById('calcDetails');
    if (detailEl) {
        detailEl.textContent = detailLines.length ? detailLines.join('\n\n') : 'No statistical details available.';
    }
    updateCodeDisplay();
}

function scheduleUpdatePlot(resetPad = false) {
    if (resetPad) autoBottomPad = 0;
    if (updateRafScheduled) return;
    updateRafScheduled = true;
    requestAnimationFrame(() => {
        updateRafScheduled = false;
        updatePlot(0);
    });
}

function getChartTitle() {
    const mainEl = document.getElementById('chartTitleInput');
    return (mainEl?.value || '').trim();
}

function syncChartTitle() {
    const mainEl = document.getElementById('chartTitleInput');
    if (!mainEl) return;
    updateExplorerTitleDisplay();
    updatePlot();
}

function updateExplorerTitleDisplay() {
    const displayEl = document.getElementById('explorerTitleDisplay');
    if (!displayEl) return;
    const title = getChartTitle();
    displayEl.textContent = title || '-';
}

function updatePlot(reflowPass = 0) {
    const mode = document.getElementById('plotMode').value;
    if (mode === 'longitudinal') {
        updateLongitudinalPlots();
        return;
    }
    const survivalMode = mode === 'survival';
    const isCompMode = mode === 'comparison';
    let timeLabels = isCompMode ? ["Data"] : getTimeLabels();
    if (!survivalMode && timeLabels.length === 0) {
        const fallbackCols = Array.from(document.querySelectorAll('.group-data-input'))
            .map(el => getColumnCount(el.value))
            .reduce((max, n) => Math.max(max, n), 0);
        if (fallbackCols > 0) {
            timeLabels = Array.from({ length: fallbackCols }, (_, i) => `Col${i + 1}`);
        }
    }
    if (!survivalMode && timeLabels.length === 0) return;

    const fsX = parseInt(document.getElementById('fontSizeX').value);
    const fsY = parseInt(document.getElementById('fontSizeY').value);
    const dotR = parseFloat(document.getElementById('dotSize').value);
    const numTicks = parseInt(document.getElementById('numTicks').value);
    const widthVal = document.getElementById('chartWidthVal');
    const heightVal = document.getElementById('chartHeightVal');
    const widthRaw = parseInt(widthVal?.value, 10);
    const heightRaw = parseInt(heightVal?.value, 10);
    const width = Number.isFinite(widthRaw) && widthRaw > 0 ? widthRaw : 300;
    const height = Number.isFinite(heightRaw) && heightRaw > 0 ? heightRaw : 200;
    if (widthVal) widthVal.value = width;
    if (heightVal) heightVal.value = height;
    if (widthVal) widthVal.value = width;
    if (heightVal) heightVal.value = height;
    const displayScale = 2;
    const svgWrapper = document.getElementById('svg-wrapper');
    const svgContainer = document.getElementById('svg-container');
    if (svgWrapper) {
        svgWrapper.style.width = `${width * displayScale}px`;
        svgWrapper.style.height = `${height * displayScale}px`;
    }
    if (svgContainer) {
        svgContainer.style.transform = `scale(${displayScale})`;
        svgContainer.style.transformOrigin = 'top left';
        svgContainer.style.width = `${width}px`;
        svgContainer.style.height = `${height}px`;
    }
    const handlePosLeft = document.getElementById('handlePosLeft');
    if (handlePosLeft) {
        handlePosLeft.textContent = `L: ${Math.round(chartOffsetX)}`;
    }
    const yMinInputEl = document.getElementById('yMinInput');
    const yMaxInputEl = document.getElementById('yMaxInput');
    const yMinManual = parseFloat(yMinInputEl.value);
    let yMaxManual = parseFloat(yMaxInputEl.value);
    const isAutoFlag = yMaxInputEl.dataset.auto !== 'false';
    const isAutoY = isAutoFlag && (!yMaxManual || yMaxManual <= 0 || yMaxInputEl.dataset.auto === 'true');
    const jitterAmount = parseFloat(document.getElementById('jitter').value);
    const autoBrackets = document.getElementById('autoBrackets').checked;
    const showLines = document.getElementById('showLines').checked;
    const showBars = document.getElementById('showBars').checked;
    syncBarControlsUI();
    const showSampleLines = document.getElementById('showSampleLines').checked;
    const showMean = document.getElementById('showMean').checked;
    const showMeanDots = document.getElementById('showMeanDots').checked;
    const showErrorBars = document.getElementById('showErrorBars').checked;
    const errorType = document.getElementById('errorType')?.value || 'se';
    const bracketOffset = parseFloat(document.getElementById('bracketOffset').value);
    const lineOptionsBody = document.getElementById('lineOptionsBody');
    if (lineOptionsBody) {
        lineOptionsBody.classList.toggle('panel-disabled', !showLines);
    }
    const bracketOffsetLabel = document.getElementById('bracketOffsetVal');
    if (bracketOffsetLabel) {
        if (bracketOffset === 0) {
            bracketOffsetLabel.textContent = 'center';
        } else {
            bracketOffsetLabel.textContent = `${bracketOffset > 0 ? '+' : ''}${bracketOffset}px`;
        }
    }
    const xAxisLabel = document.getElementById('xAxisLabel').value.trim();
    const yAxisLabel = document.getElementById('yAxisLabel').value.trim();
    const titleText = getChartTitle();
    const titleFontSize = parseFloat(document.getElementById('titleFontSize')?.value) || 10;
    const titleFontStyle = document.getElementById('titleItalic')?.checked ? 'italic' : 'normal';
    const titlePad = titleText ? (titleFontSize + 12) : 0;
    const svgBg = getCssVar('--svg-bg') || '#fff';
    const svgInk = getCssVar('--svg-ink') || '#000';
    const axisColor = svgInk;
    const xLabelOffset = parseFloat(document.getElementById('xLabelOffset').value) || 0;
    const yLabelOffset = parseFloat(document.getElementById('yLabelOffset').value) || 0;
    const xAxisFontSize = parseFloat(document.getElementById('xAxisFontSize').value) || fsX;
    const yAxisFontSize = parseFloat(document.getElementById('yAxisFontSize').value) || fsY;
    function applyAutoRotateXLabels() {
        const svgRoot = document.querySelector('#svg-container svg');
        if (!svgRoot) return;
        const labels = Array.from(svgRoot.querySelectorAll('.x-axis-label'));
        if (labels.length < 2) return;
        const basePos = labels.map(el => ({
            x: parseFloat(el.getAttribute('x')) || 0,
            y: parseFloat(el.getAttribute('y')) || 0
        }));
        const angles = [0, -15, -25, -35, -45, -60];
        for (const ang of angles) {
            labels.forEach((el, i) => {
                const { x, y } = basePos[i];
                const yAdj = ang === 0 ? 0 : 4;
                el.setAttribute('x', x);
                el.setAttribute('y', y + yAdj);
                el.setAttribute('text-anchor', ang === 0 ? 'middle' : 'end');
                if (ang === 0) {
                    el.removeAttribute('transform');
                } else {
                    el.setAttribute('transform', `rotate(${ang} ${x} ${y + yAdj})`);
                }
            });
            let overlap = false;
            for (let i = 1; i < labels.length; i++) {
                const b0 = labels[i - 1].getBBox();
                const b1 = labels[i].getBBox();
                if (b0.x + b0.width > b1.x) { overlap = true; break; }
            }
            if (!overlap) break;
        }
    }
    function schedulePadCheck() {
        if (reflowPass >= 1) return;
        const SAFETY = 20;
        const measure = () => {
            const svgRoot = document.querySelector('#svg-container svg');
            if (!svgRoot) return;
            const labels = Array.from(svgRoot.querySelectorAll('.x-axis-label'));
            const svgRect = svgRoot.getBoundingClientRect();
            if (!svgRect.height) return;
            const overflowPx = Math.max(...(labels.length ? labels.map(el => {
                const r = el.getBoundingClientRect();
                return r.bottom - svgRect.bottom;
            }) : [0]), 0);
            const svgUnitsPerPxY = height / svgRect.height;
            const overflowSvg = Math.ceil(Math.max(0, overflowPx) * svgUnitsPerPxY);
            const now = performance.now();
            targetBottomPad = Math.max(0, overflowSvg + SAFETY);

            if (targetBottomPad > autoBottomPad) {
                autoBottomPad = targetBottomPad;
                lastGrowAt = now;
                stableZeroSince = null;
                updatePlot(reflowPass + 1);
                return;
            }

            if (overflowSvg > 0) {
                stableZeroSince = null;
                return;
            }
            if (NEVER_SHRINK) return;
            if (lastGrowAt && (now - lastGrowAt) <= 300) {
                stableZeroSince = null;
                return;
            }
            if (!stableZeroSince) {
                stableZeroSince = now;
                return;
            }
            if ((now - stableZeroSince) < 300) return;

            const newPad = Math.max(targetBottomPad, autoBottomPad - 8);
            if (newPad !== autoBottomPad) {
                autoBottomPad = newPad;
                updatePlot(reflowPass + 1);
            }
        };
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                setTimeout(measure, 0);
            });
        });
    }
    if (survivalMode) {
        const { groupConfigs, maxTime } = parseSurvivalData(document.getElementById('survivalData').value);
        const xMaxEl = document.getElementById('survivalXMax');
        const xMaxInput = parseFloat(xMaxEl.value);
        const isAutoX = xMaxEl.dataset.auto !== 'false';
        const yAxisPercent = document.getElementById('survivalYAxisPercent').checked;
        const xMax = xMaxInput > 0 ? xMaxInput : maxTime;
        const svgItems = [];
        svgItems.push(`<rect class="svg-bg" x="0" y="0" width="${width}" height="${height}" fill="${svgBg}" />`);
        const safeXMax = (isAutoX || xMaxInput <= 0 || Number.isNaN(xMaxInput)) ? (maxTime || 1) : (xMax > 0 ? xMax : maxTime || 1);
        let yMax = yAxisPercent ? 100 : 1;
        yMaxInputEl.dataset.auto = 'true';
        yMaxInputEl.value = yMax;
        if (xMaxEl && (isAutoX || xMaxInput <= 0 || Number.isNaN(xMaxInput))) {
            xMaxEl.value = safeXMax;
        }
        const pL = fsY * 4.6, pB = fsX * 3 + 6 + autoBottomPad, pT = 30 + titlePad, pR = 30;
        const graphW = width - pL - pR, graphH = height - pB - pT;
        if (graphW <= 0 || graphH <= 0) {
            return;
        }
        if (graphW <= 0 || graphH <= 0) {
            return;
        }
        const xScale = (v) => pL + (v / safeXMax) * graphW;
        const yScale = (v) => height - pB - (v / yMax * graphH);
        plotMetrics = { pL, pT, graphW, graphH, width, height };

        if (titleText) {
            const titleX = width / 2 + titleOffsetX;
            const titleY = titleFontSize + 6 + titleOffsetY;
            svgItems.push(`<text class="axis-label" data-label="title" x="${titleX}" y="${titleY}" text-anchor="middle" font-size="${titleFontSize}" font-family="Arial" font-style="${titleFontStyle}" fill="${axisColor}">${titleText}</text>`);
        }
        svgItems.push(`<line x1="${pL}" y1="${height-pB}" x2="${pL}" y2="${pT}" stroke="${axisColor}" stroke-width="1.2"/>`);

        for (let i = 0; i <= numTicks; i++) {
            const val = Number((yMax / numTicks * i).toFixed(2));
            const y = yScale(val);
            svgItems.push(`<line x1="${pL}" y1="${y}" x2="${pL-5}" y2="${y}" stroke="${axisColor}" stroke-width="1.2"/>`);
            const labelVal = yAxisPercent ? `${val}%` : val;
            svgItems.push(`<text x="${pL-8}" y="${y}" text-anchor="end" dominant-baseline="central" font-size="${fsY}" font-family="Arial" fill="${axisColor}">${labelVal}</text>`);
        }

        const xTickCount = 5;
        for (let i = 0; i <= xTickCount; i++) {
            const val = (safeXMax / xTickCount) * i;
            const x = xScale(val);
            svgItems.push(`<line x1="${x}" y1="${height-pB}" x2="${x}" y2="${height-pB+5}" stroke="${axisColor}" stroke-width="1.2"/>`);
            svgItems.push(`<text class="x-axis-label" x="${x}" y="${height-pB+fsX+10}" text-anchor="middle" font-size="${fsX}" font-family="Arial" fill="${axisColor}">${Number(val.toFixed(2))}</text>`);
        }

        if (xAxisLabel) {
            const xLabelY = height - pB + xAxisFontSize + xLabelOffset + xAxisLabelOffsetY;
            const xLabelX = pL + (graphW / 2) + xAxisLabelOffsetX;
            svgItems.push(`<text class="axis-label" data-label="x" x="${xLabelX}" y="${xLabelY}" text-anchor="middle" font-size="${xAxisFontSize}" font-family="Arial" fill="${axisColor}">${xAxisLabel}</text>`);
        }
        if (yAxisLabel) {
            const yLabelX = pL - yAxisFontSize - yLabelOffset + yAxisLabelOffsetX;
            const yLabelY = pT + (graphH / 2) + yAxisLabelOffsetY;
            svgItems.push(`<text class="axis-label" data-label="y" x="${yLabelX}" y="${yLabelY}" text-anchor="middle" font-size="${yAxisFontSize}" font-family="Arial" fill="${axisColor}" transform="rotate(-90 ${yLabelX} ${yLabelY})">${yAxisLabel}</text>`);
        }

        groupConfigs.forEach((group) => {
            const lineColor = group.color === '#ffffff' ? axisColor : group.color;
            const steps = computeSurvivalCurve(group.times || []);
            if (steps.length < 2) return;
            let path = `M ${xScale(0)} ${yScale(yAxisPercent ? 100 : 1)}`;
            let prevS = 1;
            let reachedMax = false;
            for (const step of steps.slice(1)) {
                if (step.t > safeXMax) {
                    path += ` L ${xScale(safeXMax)} ${yScale(yAxisPercent ? prevS * 100 : prevS)}`;
                    reachedMax = true;
                    break;
                }
                const x = xScale(step.t);
                path += ` L ${x} ${yScale(yAxisPercent ? prevS * 100 : prevS)} L ${x} ${yScale(yAxisPercent ? step.s * 100 : step.s)}`;
                prevS = step.s;
            }
            if (!reachedMax) {
                path += ` L ${xScale(safeXMax)} ${yScale(yAxisPercent ? prevS * 100 : prevS)}`;
            }
            svgItems.push(`<path d="${path}" fill="none" stroke="${lineColor}" stroke-width="2" stroke-linejoin="round" stroke-linecap="round"/>`);
        });
        svgItems.push(`<line x1="${pL}" y1="${height-pB}" x2="${pL + graphW}" y2="${height-pB}" stroke="${axisColor}" stroke-width="1.2"/>`);

        if (document.getElementById('showLegend').checked) {
            const legendFontSize = parseFloat(document.getElementById('legendFontSize').value) || fsY;
            const legendState = document.getElementById('legendState');
            const pos = legendState ? legendState.value.split(',').map(v => parseFloat(v)) : [95, 10];
            const lxPercent = isNaN(pos[0]) ? 95 : pos[0];
            const lyPercent = isNaN(pos[1]) ? 10 : pos[1];
            const lx = pL + (graphW * (lxPercent / 100));
            const ly = pT + (graphH * (lyPercent / 100));
            svgItems.push(`<g id="legend-group" font-family="Arial" font-size="${legendFontSize}" style="cursor: move; pointer-events: all;">`);
            groupConfigs.forEach((group, i) => {
                const itemY = ly + (i * legendFontSize * 1.5);
                svgItems.push(`
        <g id="Legend_${group.name}">
            <circle cx="${lx}" cy="${itemY}" r="${dotR}" fill="${group.color}" stroke="${axisColor}" stroke-width="0.8" />
            <text x="${lx + legendFontSize}" y="${itemY}" dominant-baseline="central" fill="${axisColor}">${group.name}</text>
        </g>`);
            });
            svgItems.push(`</g>`);
        }

        document.getElementById('svg-container').innerHTML = `<svg width="${width}px" height="${height}px" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="background:${svgBg}; overflow:visible; color: ${svgInk};">${svgItems.join('')}</svg>`;
        applyAutoRotateXLabels();
        schedulePadCheck();
        const detailEl = document.getElementById('calcDetails');
        if (groupConfigs.length === 2) {
            const lr = logRankTestTwoGroups(groupConfigs[0].times, groupConfigs[1].times);
            const pText = lr ? (lr.p < 0.0001 ? "<0.0001" : lr.p.toFixed(4)) : "N/A";
            document.getElementById('statsTableContainer').innerHTML = `
                <table style="width:100%; border-collapse: collapse; font-size: 0.85rem;">
                    <thead>
                        <tr style="background:#f1f3f5; border-bottom:2px solid #dee2e6;">
                            <th style="padding:10px;">Survival Test</th>
                            <th style="padding:10px;">Z</th>
                            <th style="padding:10px;">P-value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom:1px solid var(--border);">
                            <td style="padding:8px;">Log-rank (2 groups)</td>
                            <td style="padding:8px;">${lr ? lr.z.toFixed(3) : "N/A"}</td>
                            <td style="padding:8px;">${pText}</td>
                        </tr>
                    </tbody>
                </table>`;
            if (detailEl) detailEl.textContent = lr ? `Log-rank Z=${lr.z.toFixed(3)}, p=${lr.p}` : 'Log-rank result not available.';
        } else {
            document.getElementById('statsTableContainer').innerHTML = '<p style="color: var(--muted);">Survival mode: log-rank is available only for 2 groups.</p>';
            if (detailEl) detailEl.textContent = 'Survival mode: log-rank is available only for 2 groups.';
        }
        updateCodeDisplay();
        return;
    }

    // 全グループデータの取得
    const groupCards = document.querySelectorAll('.group-card');
    groupCards.forEach(card => renderGroupTable(card));
    const groupConfigs = Array.from(groupCards).map(card => ({
        name: card.querySelector('.group-name-input').value,
        color: card.querySelector('.group-color-input').value,
        data: parseData(card.querySelector('.group-data-input').value, timeLabels.length)
    }));
    const nGroups = groupConfigs.length;
    ensureGroupOffsets(nGroups);
    ensureGroupLabelOffsets(nGroups);
    const getCompCenter = (gIdx) => pL + (gIdx + 0.5) * (graphW / nGroups) + (groupOffsetX[gIdx] || 0);
    const getTimeCenter = (tIdx, gIdx, groupSpace) => {
        const base = pL + (tIdx + 0.5) * (graphW / timeLabels.length);
        const offset = (gIdx - (nGroups - 1) / 2) * (groupSpace / nGroups);
        return base + offset + (groupOffsetX[gIdx] || 0);
    };

    // 1. まず統計計算を行い、ブラケチEが忁Eな「階層数」を把握する
    let maxBracketLayers = 0;
    timeLabels.forEach((_, tIdx) => {
        const d = groupConfigs.map(g => g.data[tIdx]).filter(x => x.length > 1);
        if (d.length === 2) {
            const res = welchTTest(d[0], d[1]);
            if (res && res.p < 0.05) maxBracketLayers = Math.max(maxBracketLayers, 1);
        } else if (d.length >= 3) {
            const a = oneWayANOVA(d);
            if (a && fDistributionP(a.f, a.df1, a.df2) < 0.05) {
                const sigCount = runDunnett(d, a.msWithin, a.df2).filter(r => r.isSig).length;
                maxBracketLayers = Math.max(maxBracketLayers, sigCount);
            }
        }
    });

    // 2. Y軸の最大値を決宁E(ブラケチEがある場合E20-30%の余白を追加)
    const allValues = groupConfigs.flatMap(g => g.data.flat());
    const statsAll = groupConfigs.flatMap(g => g.data.map(calcStats));
    const maxCandidates = [...allValues, ...statsAll.map(s => s.mean + (errorType === 'sd' ? s.sd : s.se))];
    const minCandidates = [...allValues, ...statsAll.map(s => s.mean - (errorType === 'sd' ? s.sd : s.se))];
    const rawMax = maxCandidates.length ? Math.max(...maxCandidates) : 1;
    const rawMin = minCandidates.length ? Math.min(...minCandidates) : 0;

    const baseYMax = niceCeil(rawMax);
    let yMax = yMaxManual > 0 ? yMaxManual : baseYMax;
    const yMinIsManual = yMinInputEl.dataset.auto === 'false' && Number.isFinite(yMinManual);
    let yMin = yMinIsManual ? yMinManual : Math.min(0, rawMin);

    // 有意差マEクがある場合、強制皁E上限を押し上げめE
    if (autoBrackets && maxBracketLayers > 0 && isAutoY) {
        const extraFactor = Math.min(0.1, 0.05 * maxBracketLayers);
        const expandedYMax = niceCeil(rawMax * (1 + extraFactor));
        yMax = Math.max(baseYMax, expandedYMax);
    }
    if (isAutoY) {
        yMaxInputEl.dataset.auto = 'true';
        yMaxInputEl.value = yMax;
        if (yMinInputEl) yMinInputEl.value = yMin;
    }

    const pL = fsY * 4.6, pB = fsX * 3 + 6 + autoBottomPad, pT = 30 + titlePad, pR = 30;
    const graphW = width - pL - pR, graphH = height - pB - pT;
    const yScale = (v) => height - pB - ((v - yMin) / (yMax - yMin) * graphH);
    plotMetrics = { pL, pT, graphW, graphH, width, height };

    let svgItems = [];
    svgItems.push(`<rect class="svg-bg" x="0" y="0" width="${width}" height="${height}" fill="${svgBg}" />`);
    const strokeW = 1.2;

    function drawGroupContent(x, data, s, group, barWidth, baselineVal, gIdx) {
        const errVal = errorType === 'sd' ? s.sd : s.se;
        const yM = yScale(s.mean), yT = yScale(s.mean + errVal), yB = yScale(s.mean - errVal);
        const dotR = parseFloat(document.getElementById('dotSize').value);
        const jitter = parseFloat(document.getElementById('jitter').value);

        if (showBars) {
            const baseY = yScale(baselineVal);
            const barY = Math.min(yM, baseY);
            const barH = Math.abs(baseY - yM);
            const dragClass = (draggingBarIndex === gIdx) ? ' dragging' : '';
            svgItems.push(`<rect class="bar-draggable${dragClass}" data-group-index="${gIdx}" x="${x - barWidth / 2}" y="${barY}" width="${barWidth}" height="${barH}" fill="${group.color}" fill-opacity="0.35" stroke="${axisColor}" stroke-width="0.8"/>`);
        }
        if (showErrorBars) {
            const capHalf = Math.min(5, barWidth * 0.25);
            svgItems.push(`
    <g stroke="${axisColor}" stroke-width="1.2">
        <line x1="${x}" y1="${yB}" x2="${x}" y2="${yT}" />
        <line x1="${x-capHalf}" y1="${yT}" x2="${x+capHalf}" y2="${yT}" />
        <line x1="${x-capHalf}" y1="${yB}" x2="${x+capHalf}" y2="${yB}" />
    </g>`);
            if (!showBars) {
                svgItems.push(`<line x1="${x-12}" y1="${yM}" x2="${x+12}" y2="${yM}" stroke="${axisColor}" stroke-width="1.5" />`);
            }
        }
        if (showMean) {
            data.forEach(v => {
                const j = (Math.random() - 0.5) * jitter;
                svgItems.push(`<circle cx="${x + j}" cy="${yScale(v)}" r="${dotR}" fill="${group.color}" stroke="${axisColor}" stroke-width="0.8" />`);
            });
        }
    }

    if (titleText) {
        const titleX = width / 2 + titleOffsetX;
        const titleY = titleFontSize + 6 + titleOffsetY;
        svgItems.push(`<text class="axis-label" data-label="title" x="${titleX}" y="${titleY}" text-anchor="middle" font-size="${titleFontSize}" font-family="Arial" font-style="${titleFontStyle}" fill="${axisColor}">${titleText}</text>`);
    }
    // 軸
    svgItems.push(`<line x1="${pL}" y1="${height-pB}" x2="${pL}" y2="${pT}" stroke="${axisColor}" stroke-width="${strokeW}"/>`);
    svgItems.push(`<line x1="${pL}" y1="${height-pB}" x2="${width-pR}" y2="${height-pB}" stroke="${axisColor}" stroke-width="${strokeW}"/>`);

    // Y軸目盛り
    for(let i=0; i<=numTicks; i++){
        const val = Number((yMin + (yMax - yMin) / numTicks * i).toFixed(1));
        const y = yScale(val);
        svgItems.push(`<line x1="${pL}" y1="${y}" x2="${pL-5}" y2="${y}" stroke="${axisColor}" stroke-width="${strokeW}"/>`);
        svgItems.push(`<text x="${pL-8}" y="${y}" text-anchor="end" dominant-baseline="central" font-size="${fsY}" font-family="Arial" fill="${axisColor}">${val}</text>`);
    }
    if (xAxisLabel) {
        const xLabelY = height - pB + xAxisFontSize + xLabelOffset + xAxisLabelOffsetY;
        const xLabelX = pL + (graphW / 2) + xAxisLabelOffsetX;
        svgItems.push(`<text class="axis-label" data-label="x" x="${xLabelX}" y="${xLabelY}" text-anchor="middle" font-size="${xAxisFontSize}" font-family="Arial" fill="${axisColor}">${xAxisLabel}</text>`);
    }
    if (yAxisLabel) {
        const yLabelX = pL - yAxisFontSize - yLabelOffset + yAxisLabelOffsetX;
        const yLabelY = pT + (graphH / 2) + yAxisLabelOffsetY;
        svgItems.push(`<text class="axis-label" data-label="y" x="${yLabelX}" y="${yLabelY}" text-anchor="middle" font-size="${yAxisFontSize}" font-family="Arial" fill="${axisColor}" transform="rotate(-90 ${yLabelX} ${yLabelY})">${yAxisLabel}</text>`);
    }

    // 吁EイムポイントE描画
    if (isCompMode) {
        const barWidth = Math.max(2, Math.min(barWidthState, graphW / Math.max(1, nGroups)));
        groupConfigs.forEach((group, gIdx) => {
            const x = getCompCenter(gIdx);
            const data = group.data[0] || [];
            const s = calcStats(data);
            const baselineVal = yMin < 0 ? 0 : yMin;

            if (s.n > 0) {
                drawGroupContent(x, data, s, group, barWidth, baselineVal, gIdx);
            }
            const labelY = height - pB + fsX + 10 + (groupLabelOffsetY[gIdx] || 0);
            svgItems.push(`<text class="x-axis-label group-label" data-group-index="${gIdx}" x="${x}" y="${labelY}" text-anchor="middle" font-size="${fsX}" font-family="Arial" fill="${axisColor}">${group.name}</text>`);
        });
    } else {
        if (showLines) {
            groupConfigs.forEach((group, gIdx) => {
                const points = [];
                const lineColor = group.color === '#ffffff' ? axisColor : group.color;
                if (showSampleLines) {
                    let maxSamples = 0;
                    timeLabels.forEach((label, tIdx) => {
                        const data = group.data[tIdx] || [];
                        maxSamples = Math.max(maxSamples, data.length);
                    });
                    for (let sIdx = 0; sIdx < maxSamples; sIdx++) {
                        const samplePoints = [];
                        timeLabels.forEach((label, tIdx) => {
                            const data = group.data[tIdx] || [];
                            if (data[sIdx] === undefined) return;
                const xCenter = pL + (tIdx + 0.5) * (graphW / timeLabels.length) + (groupOffsetX[gIdx] || 0);
                            const y = yScale(data[sIdx]);
                            samplePoints.push(`${xCenter},${y}`);
                        });
                        if (samplePoints.length > 1) {
                            svgItems.push(`
                <polyline points="${samplePoints.join(' ')}"
                          fill="none"
                          stroke="${lineColor}"
                          stroke-width="1"
                          opacity="0.35"
                          stroke-linejoin="round"
                          stroke-linecap="round" />
            `);
                        }
                    }
                }
                timeLabels.forEach((label, tIdx) => {
                    const data = group.data[tIdx] || [];
                    const s = calcStats(data);
                if (s.n > 0) {
                const xCenter = pL + (tIdx + 0.5) * (graphW / timeLabels.length) + (groupOffsetX[gIdx] || 0);
                    const y = yScale(s.mean);
                        const errVal = errorType === 'sd' ? s.sd : s.se;
                        const yT = yScale(s.mean + errVal);
                        const yB = yScale(s.mean - errVal);

                        points.push(`${xCenter},${y}`);
                        if (showErrorBars) {
                            svgItems.push(`
                <g stroke="${lineColor}" stroke-width="1.4">
                    <line x1="${xCenter}" y1="${yB}" x2="${xCenter}" y2="${yT}" />
                    <line x1="${xCenter-5}" y1="${yT}" x2="${xCenter+5}" y2="${yT}" />
                    <line x1="${xCenter-5}" y1="${yB}" x2="${xCenter+5}" y2="${yB}" />
                </g>`);
                        }
                        if (showMeanDots) {
                            svgItems.push(`<circle cx="${xCenter}" cy="${y}" r="${Math.max(2, dotR * 0.7)}" fill="${lineColor}" stroke="${lineColor}" stroke-width="0.8" />`);
                        }
                    }
                });

                if (showMean && !showBars && points.length > 1) {
                    svgItems.push(`
                <polyline points="${points.join(' ')}"
                          fill="none"
                          stroke="${lineColor}"
                          stroke-width="2"
                          stroke-linejoin="round"
                          stroke-linecap="round" />
            `);
                }
            });
        } else {
            timeLabels.forEach((label, tIdx) => {
                const xCenterBase = pL + (tIdx + 0.5) * (graphW / timeLabels.length);
                const groupSpace = (graphW / timeLabels.length) * 0.85;
                const barWidth = Math.max(2, Math.min(barWidthState, groupSpace / Math.max(1, groupConfigs.length)));
                const baselineVal = yMin < 0 ? 0 : yMin;

                groupConfigs.forEach((group, gIdx) => {
                    const xOffset = (gIdx - (groupConfigs.length - 1) / 2) * (groupSpace / groupConfigs.length);
                    const x = xCenterBase + xOffset + (groupOffsetX[gIdx] || 0);
                    const data = group.data[tIdx] || [];
                    const s = calcStats(data);

                    if (s.n > 0) {
                        drawGroupContent(x, data, s, group, barWidth, baselineVal, gIdx);
                    }
                });
            });
        }
        timeLabels.forEach((label, tIdx) => {
            const xCenter = pL + (tIdx + 0.5) * (graphW / timeLabels.length);
                svgItems.push(`<text class="x-axis-label" x="${xCenter}" y="${height-pB+fsX+10}" text-anchor="middle" font-size="${fsX}" font-family="Arial" fill="${axisColor}">${label}</text>`);
        });
    }

    // --- 有意差ブラケチEの描画 ---
    if (autoBrackets) {
        timeLabels.forEach((label, tIdx) => {
            const groupsData = groupConfigs.map(g => g.data[tIdx]).filter(d => d.length > 1);
            if (groupsData.length < 2) return;

            const baseCenter = pL + (tIdx + 0.5) * (graphW / timeLabels.length);
            const groupSpace = (graphW / timeLabels.length) * 0.85;
            const ctrlX = isCompMode
                ? getCompCenter(0)
                : getTimeCenter(tIdx, 0, groupSpace);

            const statsAtTime = groupsData.map(calcStats);
            const errorMaxY = Math.min(...statsAtTime.map(s => yScale(s.mean + (errorType === 'sd' ? s.sd : s.se))));
            let bracketY = errorMaxY - 15 - bracketOffset;

            if (nGroups === 2) {
                const res = welchTTest(groupsData[0], groupsData[1]);
                if (res && res.p < 0.05) {
                    if (showLines) {
                        const s2 = calcStats(groupsData[1]);
                        const err2 = errorType === 'sd' ? s2.sd : s2.se;
                        const targetX = isCompMode
                            ? getCompCenter(1)
                            : baseCenter;
                        const starY = yScale(s2.mean + err2) - 8 - bracketOffset;
                        svgItems.push(`<text x="${targetX}" y="${starY}" text-anchor="middle" font-size="${fsX * 1.2}" font-family="Arial" font-weight="bold" fill="${axisColor}">${getStars(res.p)}</text>`);
                    } else {
                        const targetX = isCompMode
                            ? getCompCenter(1)
                            : getTimeCenter(tIdx, 1, groupSpace);
                        svgItems.push(drawBracket(ctrlX, targetX, bracketY, getStars(res.p), fsX));
                    }
                }
            } else {
                const a = oneWayANOVA(groupsData);
                if (a && fDistributionP(a.f, a.df1, a.df2) < 0.05) {
                    const dunnettRes = runDunnett(groupsData, a.msWithin, a.df2);
                    dunnettRes.forEach((res, i) => {
                        if (res.isSig) {
                            const targetX = isCompMode
                                ? getCompCenter(i + 1)
                                : getTimeCenter(tIdx, i + 1, groupSpace);
                            svgItems.push(drawBracket(ctrlX, targetX, bracketY, getStars(res.p), fsX));
                            bracketY -= 22;
                        }
                    });
                }
            }
        });
    }

    // --- Legend Generation ---
    if (document.getElementById('showLegend').checked) {
        const legendFontSize = parseFloat(document.getElementById('legendFontSize').value) || fsY;
        const legendState = document.getElementById('legendState');
        const pos = legendState ? legendState.value.split(',').map(v => parseFloat(v)) : [85, 10];
        const lxPercent = isNaN(pos[0]) ? 85 : pos[0];
        const lyPercent = isNaN(pos[1]) ? 10 : pos[1];
        const lx = pL + (graphW * (lxPercent / 100));
        const ly = pT + (graphH * (lyPercent / 100));

        svgItems.push(`<g id="legend-group" font-family="Arial" font-size="${legendFontSize}" style="cursor: move; pointer-events: all;">`);
        groupConfigs.forEach((group, i) => {
            const itemY = ly + (i * legendFontSize * 1.5);
            svgItems.push(`
        <g id="Legend_${group.name}">
            <circle cx="${lx}" cy="${itemY}" r="${dotR}" fill="${group.color}" stroke="${axisColor}" stroke-width="${strokeW * 0.8}" />
            <text x="${lx + legendFontSize}" y="${itemY}" dominant-baseline="central" fill="${axisColor}">${group.name}</text>
        </g>`);
        });
        svgItems.push(`</g>`);
    }

    document.getElementById('svg-container').innerHTML = `<svg width="${width}px" height="${height}px" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="background:${svgBg}; overflow:visible; color: ${svgInk};">${svgItems.join('')}</svg>`;
    applyAutoRotateXLabels();
    schedulePadCheck();
    displayStats(timeLabels, groupConfigs);
}

let toastTimer;
function showToast(message) {
    const toast = document.getElementById('toast');
    if (!toast) return;
    toast.textContent = message;
    toast.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove('show'), 1200);
}

async function downloadSVG() {
    const svg = document.querySelector('#svg-container svg');
    if (!svg) {
        showToast('No chart to export.');
        return;
    }
    await exportSvgElement(svg, 'svg', getExportBaseName('MultiGroup_Figure'));
}

function setAutoYMax() {
    const yMaxInputEl = document.getElementById('yMaxInput');
    const yMinInputEl = document.getElementById('yMinInput');
    yMaxInputEl.dataset.auto = 'true';
    yMaxInputEl.value = '0';
    if (yMinInputEl) {
        yMinInputEl.dataset.auto = 'true';
        yMinInputEl.value = '0';
    }
    updatePlot();
}

function setErrorType(type) {
    const input = document.getElementById('errorType');
    input.value = type;
    const semBtn = document.getElementById('err-sem');
    const sdBtn = document.getElementById('err-sd');
    semBtn.classList.toggle('active', type === 'se');
    sdBtn.classList.toggle('active', type === 'sd');
    updatePlot();
}

function adjustLabelOffset(id, delta) {
    const input = document.getElementById(id);
    if (!input) return;
    const current = parseFloat(input.value) || 0;
    input.value = current + delta;
    updatePlot();
}

function syncChartSize(axis) {
    const widthVal = document.getElementById('chartWidthVal');
    const heightVal = document.getElementById('chartHeightVal');
    updatePlot();
}

function downloadCSV() {
    const mode = document.getElementById('plotMode').value;
    const isCompMode = mode === 'comparison';
    const timeLabels = isCompMode ? ["Data"] : getTimeLabels();
    if (!timeLabels.length) return;

    const groupCards = document.querySelectorAll('.group-card');
    const groupConfigs = Array.from(groupCards).map(card => ({
        name: card.querySelector('.group-name-input').value,
        data: parseData(card.querySelector('.group-data-input').value, timeLabels.length)
    }));

    const lines = [];
    lines.push('RawData');
    lines.push('Time,Group,Value');
    timeLabels.forEach((label, tIdx) => {
        groupConfigs.forEach((group) => {
            const data = group.data[tIdx] || [];
            data.forEach((v) => {
                lines.push(`${label},${group.name},${v}`);
            });
        });
    });
    lines.push('');
    lines.push('Summary');
    lines.push('Time,Group,Mean,SD,SE,N');
    timeLabels.forEach((label, tIdx) => {
        groupConfigs.forEach((group) => {
            const data = group.data[tIdx] || [];
            const s = calcStats(data);
            lines.push(`${label},${group.name},${s.mean},${s.sd},${s.se},${s.n}`);
        });
    });

    const csv = lines.join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `plot_data_${new Date().getTime()}.csv`;
    link.click();
}

function downloadStatsCode() {
    const mode = document.getElementById('plotMode').value;
    const isCompMode = mode === 'comparison';
    const timeLabels = isCompMode ? ["Data"] : getTimeLabels();
    if (!timeLabels.length) return;

    const groupCards = document.querySelectorAll('.group-card');
    const groupConfigs = Array.from(groupCards).map(card => ({
        name: card.querySelector('.group-name-input').value,
        data: parseData(card.querySelector('.group-data-input').value, timeLabels.length)
    }));

    const rows = [];
    timeLabels.forEach((label, tIdx) => {
        groupConfigs.forEach((group) => {
            const data = group.data[tIdx] || [];
            data.forEach((v) => {
                rows.push(`  "${label}", "${group.name}", ${v}`);
            });
        });
    });

    const rScript = `# Generated from current app data
# Paste into R as-is
df <- read.csv(text = '
Time,Group,Value
${rows.join('\n')}
', stringsAsFactors = FALSE)

df$Time <- as.factor(df$Time)
df$Group <- as.factor(df$Group)

# Summary (mean, sd, se)
library(dplyr)
summary_stats <- df %>%
  group_by(Time, Group) %>%
  summarise(
    mean = mean(Value),
    sd = sd(Value),
    se = sd(Value) / sqrt(n()),
    n = n(),
    .groups = "drop"
  )
print(summary_stats)

# Two-group Welch t-test + Brunner-Munzel per Time
if (length(levels(df$Group)) == 2) {
  if (!requireNamespace("lawstat", quietly = TRUE)) {
    install.packages("lawstat")
  }
  by(df, df$Time, function(sub) {
    print(t.test(Value ~ Group, data = sub))
    print(lawstat::brunner.munzel.test(Value ~ Group, data = sub))
  })
} else {
  # One-way ANOVA per Time
  by(df, df$Time, function(sub) {
    print(summary(aov(Value ~ Group, data = sub)))
  })
}
`;

    const blob = new Blob([rScript], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `statistical_code_${new Date().getTime()}.R`;
    link.click();
}

async function copySvgToClipboard() {
    const svgEl = document.querySelector('#svg-container svg');
    if (!svgEl) return;
    let svgData = new XMLSerializer().serializeToString(svgEl);
    const theme = document.documentElement.getAttribute('data-theme');
    const lightSvgBg = '#F6F0E3';
    const lightSvgInk = '#2B2A27';
    if (theme === 'dark') {
        const darkSvgBg = getCssVar('--svg-bg') || '#1C2226';
        const darkSvgInk = getCssVar('--svg-ink') || '#E7E7E7';
        svgData = svgData.split(darkSvgBg).join(lightSvgBg);
        svgData = svgData.split(darkSvgInk).join(lightSvgInk);
    }
    svgData = svgData.replace(`background:${lightSvgBg};`, 'background:transparent;');
    svgData = svgData.replace(/<rect class="svg-bg"[^>]*?>/, '');
    const svgBlob = new Blob([svgData], { type: "image/svg+xml" });

    try {
        const width = parseInt(svgEl.getAttribute('width')) || 800;
        const height = parseInt(svgEl.getAttribute('height')) || 600;
        const img = new Image();
        const url = URL.createObjectURL(svgBlob);

        await new Promise((resolve, reject) => {
            img.onload = () => resolve();
            img.onerror = reject;
            img.src = url;
        });

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        URL.revokeObjectURL(url);

        const pngBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));

        if (navigator.clipboard && window.ClipboardItem && pngBlob) {
            const item = new ClipboardItem({
                'image/png': pngBlob,
                'image/svg+xml': svgBlob,
                'text/plain': new Blob([svgData], { type: 'text/plain' })
            });
            await navigator.clipboard.write([item]);
            showToast('Copied');
        } else if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(svgData);
            showToast('Copied');
        }
    } catch (err) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(svgData);
            showToast('Copied');
        }
    }
}


// 初期グループE作E
const resizer = document.getElementById("resizerHandle");
const leftPanel = document.getElementById("leftPanel");
const svgWrapper = document.getElementById("svg-wrapper");
const sizeHandles = document.querySelectorAll('.resize-handle');

if (svgWrapper && window.ResizeObserver) {
    const ro = new ResizeObserver(() => {
        scheduleUpdatePlot(true);
    });
    ro.observe(svgWrapper);
}

resizer.addEventListener("mousedown", function(e) {
    e.preventDefault();
    document.addEventListener("mousemove", resize);
    document.addEventListener("mouseup", stopResize);
    resizer.style.background = "#007bff";
});

function resize(e) {
    const newWidth = e.clientX;
    if (newWidth >= 0 && newWidth < 800) {
        leftPanel.style.flex = `0 0 ${newWidth}px`;
    }
}

function stopResize() {
    document.removeEventListener("mousemove", resize);
    resizer.style.background = "";
}

function handleContextMenu() {
    copySvgToClipboard();
}

if (svgWrapper) {
    svgWrapper.addEventListener("contextmenu", handleContextMenu);
}

let resizingChart = false;
let resizeHandle = null;
let startX = 0;
let startY = 0;
let startW = 0;
let startH = 0;
let startOffsetX = 0;
let startOffsetY = 0;

sizeHandles.forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
        resizingChart = true;
        resizeHandle = handle.dataset.handle;
        startX = e.clientX;
        startY = e.clientY;
        startW = parseInt(document.getElementById('chartWidthVal').value, 10);
        startH = parseInt(document.getElementById('chartHeightVal').value, 10);
        startOffsetX = chartOffsetX;
        startOffsetY = chartOffsetY;
        e.preventDefault();
    });
});

window.addEventListener('mousemove', (e) => {
    if (!resizingChart) return;
    const scale = getDisplayScale();
    const dx = (e.clientX - startX) / scale;
    const dy = (e.clientY - startY) / scale;
    let newW = startW;
    let newH = startH;

    if (resizeHandle === 'tr' || resizeHandle === 'br') newW = startW + dx;
    if (resizeHandle === 'tl' || resizeHandle === 'bl') {
        newW = startW - dx;
        chartOffsetX = startOffsetX + dx;
    }
    if (resizeHandle === 'bl' || resizeHandle === 'br') newH = startH + dy;
    if (resizeHandle === 'tl' || resizeHandle === 'tr') {
        newH = startH - dy;
        chartOffsetY = startOffsetY + dy;
    }

    newW = Math.max(10, Math.round(newW));
    newH = Math.max(10, Math.round(newH));

    document.getElementById('chartWidthVal').value = newW;
    document.getElementById('chartHeightVal').value = newH;
    if (svgWrapper) {
        svgWrapper.style.transform = `translate(${chartOffsetX}px, ${chartOffsetY}px)`;
    }
    const handlePosLeft = document.getElementById('handlePosLeft');
    if (handlePosLeft) {
        handlePosLeft.textContent = `L: ${Math.round(chartOffsetX)}`;
    }
    scheduleUpdatePlot();
});

window.addEventListener('mouseup', () => {
    resizingChart = false;
    resizeHandle = null;
});

</script>
</body>
</html>
